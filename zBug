#!/usr/bin/python

import sys, os, platform, commands, stat
from PySide import QtCore, QtGui

if len(sys.argv) <= 1:
  print "Usage: llvd <executable> [<arg> ...]"
  sys.exit(1)
executable = sys.argv[1]
arguments = sys.argv[2:]

#----------------------------------------------------------------------
# Code that auto imports LLDB (from LLDB source code)
#----------------------------------------------------------------------
try: 
    # Just try for LLDB in case PYTHONPATH is already correctly setup
    import lldb
except ImportError:
    lldb_python_dirs = list()
    # lldb is not in the PYTHONPATH, try some defaults for the current platform
    platform_system = platform.system()
    if platform_system == 'Darwin':
        # On Darwin, try the currently selected Xcode directory
        xcode_dir = commands.getoutput("xcode-select --print-path")
        if xcode_dir:
            lldb_python_dirs.append(os.path.realpath(xcode_dir + '/../SharedFrameworks/LLDB.framework/Resources/Python'))
            lldb_python_dirs.append(xcode_dir + '/Library/PrivateFrameworks/LLDB.framework/Resources/Python')
        lldb_python_dirs.append('/System/Library/PrivateFrameworks/LLDB.framework/Resources/Python')
    success = False
    for lldb_python_dir in lldb_python_dirs:
        if os.path.exists(lldb_python_dir):
            if not (sys.path.__contains__(lldb_python_dir)):
                sys.path.append(lldb_python_dir)
                try: 
                    import lldb
                except ImportError:
                    pass
                else:
                    success = True
                    break
    if not success:
        print "error: couldn't locate the 'lldb' module, please set PYTHONPATH correctly"
        sys.exit(1)

debugger = lldb.SBDebugger.Create()
debugger.SetAsync(True)

# Search PATH for executable
def resolveExecutable(executable):
  pathDirs = os.environ['PATH'].split(":")
  for pathDir in pathDirs:
    pathedExecutable = os.path.join(pathDir, executable)
    try:
      if stat.S_ISREG(os.stat(pathedExecutable).st_mode):
        return pathedExecutable
    except IOError as e:
      pass
executable = resolveExecutable(executable)
target = debugger.CreateTargetWithFileAndArch(executable, lldb.LLDB_ARCH_DEFAULT)

app = QtGui.QApplication([])
app.setOrganizationName("zBug")
app.setApplicationName("zBug")
app.setApplicationVersion("0.2.0")

settings = QtCore.QSettings()

font = QtGui.QFont()
font.setPointSize(12)
font.setFamily("Courier")

class LineNumberArea(QtGui.QWidget):
  def __init__(self, sourceCodeDisplayWidget):
    QtGui.QWidget.__init__(self, sourceCodeDisplayWidget)
    self.__sourceCodeDisplayWidget = sourceCodeDisplayWidget

  def sizeHint(self):
    return QtCore.QSize(self.__sourceCodeDisplayWidget.lineNumberAreaWidth(), 0)

  def paintEvent(self, event):
    self.__sourceCodeDisplayWidget.lineNumberAreaPaintEvent(event)

class CodeDisplayWidget(QtGui.QPlainTextEdit):
  def __init__(self):
    QtGui.QPlainTextEdit.__init__(self)

    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setFont(font)
    self.setCenterOnScroll(True)

    lineNumberArea = LineNumberArea(self)
    self.__lineNumberArea = lineNumberArea

    self.__marginLabels = [" "]
    self.__maxMarginLabelLen = 1

    def updateLineNumberArea(rect, dy):
      if dy != 0:
        lineNumberArea.scroll(0, dy)
      else:
        lineNumberArea.update(0, rect.y(), lineNumberArea.width(), rect.height())

      if rect.contains(self.viewport().rect()):
        self.updateLineNumberAreaWidth()
    self.updateRequest.connect(updateLineNumberArea)

    self.updateLineNumberAreaWidth()

  def resizeEvent(self, event):
    QtGui.QWidget.resizeEvent(self, event)
    cr = self.contentsRect()
    self.__lineNumberArea.setGeometry(
      QtCore.QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height())
      )

  def lineNumberAreaWidth(self):
    return 3 + self.fontMetrics().width('X') * self.__maxMarginLabelLen + 3

  def updateLineNumberAreaWidth(self):
    self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

  def lineNumberAreaPaintEvent(self, event):
    lineNumberArea = self.__lineNumberArea
    painter = QtGui.QPainter(lineNumberArea)
    painter.fillRect(event.rect(), QtCore.Qt.lightGray)
    block = self.firstVisibleBlock()
    blockNumber = block.blockNumber()
    top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
    bottom = top + int(self.blockBoundingRect(block).height())
    while block.isValid() and top <= event.rect().bottom():
      if block.isVisible() and bottom >= event.rect().top():
        marginLabel = self.__marginLabels[blockNumber]
        painter.setPen(QtCore.Qt.black)
        painter.drawText(
          0, top,
          lineNumberArea.width() - 3, self.fontMetrics().height(),
          QtCore.Qt.AlignRight, marginLabel
          )
      block = block.next()
      top = bottom
      bottom = top + int(self.blockBoundingRect(block).height())
      blockNumber = blockNumber + 1
    
  def highlightLine(self, lineNumber):
    document = self.document()
    block = document.findBlockByLineNumber(lineNumber)
    textCursor = self.textCursor()
    textCursor.setPosition(block.position())
    self.setTextCursor(textCursor)

    selection = QtGui.QTextEdit.ExtraSelection()
    lineColor = QtGui.QColor(QtCore.Qt.yellow).lighter(160)
    selection.format.setBackground(lineColor)
    selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
    selection.cursor = textCursor
    selection.cursor.clearSelection()
    self.setExtraSelections([selection]);

  def setContents(self, contents):
    self.__marginLabels = []
    self.__maxMarginLabelLen = 1
    self.clear()
    for contentItem in contents:
      self.__marginLabels.append(contentItem[0])
      marginLabelLen = len(contentItem[0])
      if marginLabelLen > self.__maxMarginLabelLen:
        self.__maxMarginLabelLen = marginLabelLen
      self.appendPlainText(contentItem[1])
    self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

class SourceCodeDisplayWidget(QtGui.QPlainTextEdit):
  def __init__(self, parent=None):
    QtGui.QPlainTextEdit.__init__(self, parent)

    self.__pathname = None

    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setFont(font)
    self.setCenterOnScroll(True)

    lineNumberArea = LineNumberArea(self)
    self.__lineNumberArea = lineNumberArea

    def updateLineNumberAreaWidth(newBlockCount):
      self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)
    self.blockCountChanged.connect(updateLineNumberAreaWidth)

    def updateLineNumberArea(rect, dy):
      if dy != 0:
        lineNumberArea.scroll(0, dy)
      else:
        lineNumberArea.update(0, rect.y(), lineNumberArea.width(), rect.height())

      if rect.contains(self.viewport().rect()):
        updateLineNumberAreaWidth(0)
    self.updateRequest.connect(updateLineNumberArea)

    updateLineNumberAreaWidth(0)

  def resizeEvent(self, event):
    QtGui.QWidget.resizeEvent(self, event)
    cr = self.contentsRect()
    self.__lineNumberArea.setGeometry(
      QtCore.QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height())
      )

  def lineNumberAreaWidth(self):
    digits = 1
    max = self.blockCount()
    if max < 1:
      max = 1
    while max >= 10:
      max = max / 10
      digits = digits + 1
    return 3 + self.fontMetrics().width('9') * digits + 3

  def lineNumberAreaPaintEvent(self, event):
    lineNumberArea = self.__lineNumberArea
    painter = QtGui.QPainter(lineNumberArea)
    painter.fillRect(event.rect(), QtCore.Qt.lightGray)
    block = self.firstVisibleBlock()
    blockNumber = block.blockNumber()
    top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
    bottom = top + int(self.blockBoundingRect(block).height())
    while block.isValid() and top <= event.rect().bottom():
      if block.isVisible() and bottom >= event.rect().top():
        blockNumberText = str(blockNumber + 1)
        painter.setPen(QtCore.Qt.black)
        painter.drawText(
          0, top,
          lineNumberArea.width() - 3, self.fontMetrics().height(),
          QtCore.Qt.AlignRight, blockNumberText
          )
      block = block.next()
      top = bottom
      bottom = top + int(self.blockBoundingRect(block).height())
      blockNumber = blockNumber + 1
    
  def highlightLine(self, lineNumber):
    document = self.document()
    block = document.findBlockByLineNumber(lineNumber)
    textCursor = self.textCursor()
    textCursor.setPosition(block.position())
    self.setTextCursor(textCursor)

    selection = QtGui.QTextEdit.ExtraSelection()
    lineColor = QtGui.QColor(QtCore.Qt.yellow).lighter(160)
    selection.format.setBackground(lineColor)
    selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
    selection.cursor = textCursor
    selection.cursor.clearSelection()
    self.setExtraSelections([selection]);

  def updateDisplay(self, pathname, lineNumber):
    newPathname = pathname != self.__pathname
    self.__pathname = pathname

    if len(pathname) > 0:
      if newPathname:
        try:
          f = open(pathname, 'r')
          contents = f.read()
          f.close()
        except IOError as e:
          contents = "Unable to read file:\n  %s\n" % str(e)
          lineNumber = 0
        self.setPlainText(contents)
    else:
      self.setPlainText("No source code for this location")
      lineNumber = 0

    if lineNumber >= 1:
      self.highlightLine(lineNumber - 1)
    else:
      self.setExtraSelections([])

  def updateDisplayForLineEntry(self, lineEntry):
    fileSpec = lineEntry.GetFileSpec()
    if fileSpec.GetFilename():
      pathname = str(fileSpec)
    else:
      pathname = ""
    lineNumber = lineEntry.GetLine()
    self.updateDisplay(pathname, lineNumber)

sourceCodeDisplayWidget = SourceCodeDisplayWidget()
sourceCodeDisplayWidget.setReadOnly(True)

class DisassemblyDisplayWidget(CodeDisplayWidget):
  def __init__(self):
    CodeDisplayWidget.__init__(self)

    self.__functionOrSymbol = None

  def frame(self):
    return self.__frame

  def setFrame(self, frame):
    self.__frame = frame
    pc = frame.GetPC()

    functionOrSymbol = frame.GetFunction()
    if not functionOrSymbol:
      functionOrSymbol = frame.GetSymbol()
    newFunctionOrSymbol = functionOrSymbol != self.__functionOrSymbol
    self.__functionOrSymbol = functionOrSymbol

    instructions = functionOrSymbol.GetInstructions(target)
    if newFunctionOrSymbol:
      self.clear()
    count = instructions.GetSize()
    contents = []
    lineNumberToHighlight = None
    for i in range(0, count):
      instruction = instructions.GetInstructionAtIndex(i)
      address = instruction.GetAddress()
      loadAddress = address.GetLoadAddress(target)
      if loadAddress == pc:
        lineNumberToHighlight = i
      if newFunctionOrSymbol:
        mnemonic = instruction.GetMnemonic(target)
        operands =  instruction.GetOperands(target)
        comment =  instruction.GetComment(target)
        desc = "%-8s %s" % (mnemonic, operands)
        if comment:
          if len(desc) < 32:
            desc += ' ' * (32 - len(desc))
          desc += "; %s" % comment
        contents.append(["%#x" % loadAddress, desc])
    if newFunctionOrSymbol:
      self.setContents(contents)

    if lineNumberToHighlight != None:
      self.highlightLine(lineNumberToHighlight)
    else:
      self.setExtraSelections([])

disassemblyDisplayWidget = DisassemblyDisplayWidget()

class ValueWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self, value, includeType):
    QtGui.QTreeWidgetItem.__init__(self)

    self.__value = value
    self.__includeType = includeType
    self.__expanded = False
    self.__existingChildren = {}
    self.__wasExpanded = False

    self.setFont(0, font)
    self.setFont(1, font)
    if includeType:
      self.setFont(2, font)

    self.__dynamicColor = QtGui.QColor(QtCore.Qt.red).lighter(190)

  def expanded(self):
    if not self.__expanded:
      self.__expanded = True
      self.update()

  def collapsed(self):
    if self.__expanded:
      self.__expanded = False
      self.update()

  def value(self):
    return self.__value

  def update(self):
    value = self.__value
    includeType = self.__includeType

    self.setText(0, value.GetName())

    self.setText(1, value.GetValue())
    if value.GetValueDidChange():
      self.setBackground(1, self.__dynamicColor)
    else:
      self.setBackground(1, self.background(0))

    if includeType:
      self.setText(2, value.GetTypeName())

    if value.GetNumChildren() > 0:
      self.setChildIndicatorPolicy(QtGui.QTreeWidgetItem.ShowIndicator)
    else:
      self.setChildIndicatorPolicy(QtGui.QTreeWidgetItem.DontShowIndicator)

    self.takeChildren()
    if self.__expanded:
      count = value.GetNumChildren()
      for i in range(0, count):
        childValue = value.GetChildAtIndex(i)
        childValueName = childValue.GetName()
        if childValueName in self.__existingChildren:
          childValueWidgetItem = self.__existingChildren[childValueName]
        else:
          childValueWidgetItem = ValueWidgetItem(childValue, self.__includeType)
          self.__existingChildren[childValueName] = childValueWidgetItem
        self.addChild(childValueWidgetItem)
        childValueWidgetItem.update()
    else:
      self.__existingChildren = {}

  def saveExpansionState(self):
    self.__wasExpanded = self.treeWidget().isItemExpanded(self)
    for i in range(0, self.childCount()):
      self.child(i).saveExpansionState()

  def restoreExpansionState(self):
    for i in range(0, self.childCount()):
      self.child(i).restoreExpansionState()
    if self.__wasExpanded:
      self.treeWidget().expandItem(self)
    else:
      self.treeWidget().collapseItem(self)

class LocalsWidget(QtGui.QTreeWidget):
  def __init__(self):
    QtGui.QTreeWidget.__init__(self)

    self.__existingItems = {}

    self.setEnabled(False)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(12)
    self.setHeaderLabels([
      "Name",
      "Value",
      "Type"
    ])

    settings.beginGroup("LocalsWidget")
    self.setColumnWidth(0, settings.value("firstColumnWidth", 120))
    self.setColumnWidth(1, settings.value("secondColumnWidth", 200))
    settings.endGroup()

    def itemExpanded(item):
      item.expanded()
    self.itemExpanded.connect(itemExpanded)
    def itemCollapsed(item):
      item.collapsed()
    self.itemCollapsed.connect(itemCollapsed)

  def hideEvent(self, event):
    settings.beginGroup("LocalsWidget")
    settings.setValue("firstColumnWidth", self.columnWidth(0))
    settings.setValue("secondColumnWidth", self.columnWidth(1))
    settings.endGroup()
    QtGui.QTreeWidget.hideEvent(self, event)

  def setFrame(self, frame):
    enabled = False
    if frame and frame.IsValid():
      includeArguments = True
      includeLocals = True
      includeStatics = True
      in_scope_only = True
      variables = frame.GetVariables(
        includeArguments,
        includeLocals,
        includeStatics,
        in_scope_only
        )

      for i in range(0, self.topLevelItemCount()):
        self.topLevelItem(i).saveExpansionState()

      while self.topLevelItemCount() > 0:
        self.takeTopLevelItem(0)

      count = variables.GetSize()
      for i in range(0, count):
        value = variables.GetValueAtIndex(i)
        valueName = value.GetName()
        if valueName in self.__existingItems:
          valueWidgetItem = self.__existingItems[valueName]
        else:
          valueWidgetItem = ValueWidgetItem(value, includeType=True)
          self.__existingItems[valueName] = valueWidgetItem

        self.addTopLevelItem(valueWidgetItem)
        valueWidgetItem.update()

      for i in range(0, self.topLevelItemCount()):
        self.topLevelItem(i).restoreExpansionState()

      enabled = True
    self.setEnabled(enabled)

localsWidget = LocalsWidget()

class RegistersWidget(QtGui.QTreeWidget):
  def __init__(self):
    QtGui.QTreeWidget.__init__(self)

    self.__existingItems = {}

    self.setEnabled(False)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(12)
    self.setHeaderLabels([
      "Name",
      "Value"
    ])

    settings.beginGroup("RegistersWidget")
    self.setColumnWidth(0, settings.value("firstColumnWidth", 80))
    settings.endGroup()

    def itemExpanded(item):
      item.expanded()
    self.itemExpanded.connect(itemExpanded)
    def itemCollapsed(item):
      item.collapsed()
    self.itemCollapsed.connect(itemCollapsed)

  def hideEvent(self, event):
    settings.beginGroup("RegistersWidget")
    settings.setValue("firstColumnWidth", self.columnWidth(0))
    settings.endGroup()
    QtGui.QTreeWidget.hideEvent(self, event)

  def setFrame(self, frame):
    enabled = False
    if frame and frame.IsValid():
      registers = frame.GetRegisters()
 
      for i in range(0, self.topLevelItemCount()):
        self.topLevelItem(i).saveExpansionState()

      while self.topLevelItemCount() > 0:
        self.takeTopLevelItem(0)

      count = registers.GetSize()
      for i in range(0, count):
        value = registers.GetValueAtIndex(i)
        valueName = value.GetName()
        if valueName in self.__existingItems:
          valueWidgetItem = self.__existingItems[valueName]
        else:
          valueWidgetItem = ValueWidgetItem(value, includeType=False)
          self.__existingItems[valueName] = valueWidgetItem

        self.addTopLevelItem(valueWidgetItem)
        valueWidgetItem.update()

      for i in range(0, self.topLevelItemCount()):
        self.topLevelItem(i).restoreExpansionState()

      enabled = True
    self.setEnabled(enabled)

registersWidget = RegistersWidget()

class StackWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self, frame):
    QtGui.QTreeWidgetItem.__init__(self)

    self.__frame = frame

    self.setFont(0, font)
    self.setFont(1, font)
    self.setTextAlignment(1, QtCore.Qt.AlignRight)
    self.setFont(2, font)

    self.setText(0, "%d" % frame.GetFrameID())
    self.setText(1, "%#x" % frame.GetPC())
    self.setText(2, "%s" % (frame.GetFunctionName()))

  def frame(self):
    return self.__frame

class StackWidget(QtGui.QTreeWidget):
  def __init__(
    self,
    sourceCodeDisplayWidget,
    disassemblyDisplayWidget,
    localsWidget,
    registersWidget
    ):
    QtGui.QTreeWidget.__init__(self)

    self.__sourceCodeDisplayWidget = sourceCodeDisplayWidget
    self.__disassemblyDisplayWidget = disassemblyDisplayWidget
    self.__localsWidget = localsWidget
    self.__registersWidget = registersWidget

    self.setEnabled(False)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(0)
    self.setHeaderLabels([
      "#",
      "PC",
      "Location"
    ])

    def currentItemChanged(newItem, oldItem):
      currentItem = self.currentItem()
      if currentItem:
        frameIndex = self.indexOfTopLevelItem(currentItem)
        thread = self.__process.GetSelectedThread()
        thread.SetSelectedFrame(frameIndex)

        frame = thread.GetFrameAtIndex(frameIndex)
        self.__sourceCodeDisplayWidget.updateDisplayForLineEntry(frame.GetLineEntry())
        self.__disassemblyDisplayWidget.setFrame(frame)
      else:
        frame = None
      self.__localsWidget.setFrame(frame)
      self.__registersWidget.setFrame(frame)
    self.currentItemChanged.connect(currentItemChanged)

  def updateDisplay(self, process):
    self.setCurrentItem(None)
    enabled = False
    self.__process = None

    if process and process.IsValid() and process.GetState() == lldb.eStateStopped:
      thread = process.GetSelectedThread()
      if thread and thread.IsValid():
        count = thread.GetNumFrames()
        if count > 0:
          self.__process = process

          selectedFrame = thread.GetSelectedFrame()
          selectedFrameID = selectedFrame.GetFrameID()

          self.clear()
          for i in range(0, count):
            frame = thread.GetFrameAtIndex(i)
            stackWidgetItem = StackWidgetItem(frame)
            self.addTopLevelItem(stackWidgetItem)
            if frame.GetFrameID() == selectedFrameID:
              self.setCurrentItem(stackWidgetItem)

          self.resizeColumnToContents(0)
          self.resizeColumnToContents(1)

          enabled = True
    self.setEnabled(enabled)

stackWidget = StackWidget(
  sourceCodeDisplayWidget,
  disassemblyDisplayWidget,
  localsWidget,
  registersWidget
  )

class ThreadsWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self, thread):
    QtGui.QTreeWidgetItem.__init__(self)

    self.setFont(0, font)
    self.setFont(1, font)
    self.setFont(2, font)
    self.setFont(3, font)

    process = thread.GetProcess()
    frame = thread.GetFrameAtIndex(0)

    self.setText(0, "%u" % thread.GetIndexID())
    self.setText(1, "%#x" % thread.GetThreadID())
    self.setText(2, thread.GetName())
    locationDesc = "%s" % (frame.GetFunctionName())
    self.setText(3, locationDesc)

class ThreadsWidget(QtGui.QTreeWidget):
  def __init__(
    self,
    stackWidget
    ):
    QtGui.QTreeWidget.__init__(self)

    self.__stackWidget = stackWidget

    self.setEnabled(False)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(0)
    self.setHeaderLabels([
      "#",
      "TID",
      "Name",
      "Location"
    ])

    def currentItemChanged(newItem, oldItem):
      currentItem = self.currentItem()
      if currentItem:
        threadIndex = self.indexOfTopLevelItem(currentItem)
        thread = self.__process.GetThreadAtIndex(int(threadIndex))
        self.__process.SetSelectedThread(thread)
      else:
        thread = None
      self.__stackWidget.updateDisplay(self.__process)
    self.currentItemChanged.connect(currentItemChanged)

  def updateDisplay(self, process):
    self.setCurrentItem(None)
    self.__process = None
    enabled = False

    if process and process.IsValid() and process.GetState() == lldb.eStateStopped:
      self.__process = process

      count = process.GetNumThreads()
      selectedThread = process.GetSelectedThread()
      selectedThreadID = selectedThread.GetThreadID()

      self.clear()
      for i in range(0, count):
        thread = process.GetThreadAtIndex(i)
        threadWidgetItem = ThreadsWidgetItem(thread)
        self.addTopLevelItem(threadWidgetItem)
        if thread.GetThreadID() == selectedThreadID:
          self.setCurrentItem(threadWidgetItem)

      self.resizeColumnToContents(0)
      self.resizeColumnToContents(1)

      enabled = True
    self.setEnabled(enabled)

threadsWidget = ThreadsWidget(stackWidget)

class AppendingTextWidget(QtGui.QTextEdit):
  def __init__(self):
    QtGui.QTextEdit.__init__(self)

    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setFont(font)

  def append(self, text, color):
    self.setTextColor(color)
    charFormat = self.currentCharFormat()
    textCursor = self.textCursor()
    textCursor.movePosition(QtGui.QTextCursor.End)
    textCursor.insertText(text, charFormat)
    self.ensureCursorVisible()

class OutputWidget(AppendingTextWidget):
  def __init__(self):
    AppendingTextWidget.__init__(self)

    self.__stdoutColor = QtGui.QColor(QtCore.Qt.black)
    self.__stderrColor = QtGui.QColor(QtCore.Qt.red).lighter(50)

  def appendStdout(self, text):
    self.append(text, self.__stdoutColor)

  def appendStderr(self, text):
    self.append(text, self.__stderrColor)

outputWidget = OutputWidget()

class SourcesFilterWidget(QtGui.QLineEdit):
  filterChanged = QtCore.Signal(basestring)

  def __init__(self):
    QtGui.QLineEdit.__init__(self)

    self.setFont(font)

    def returnPressed():
      text = self.text()
      self.selectAll()
      self.filterChanged.emit(text)
    self.returnPressed.connect(returnPressed)

sourcesFilterWidget = SourcesFilterWidget()
sourcesFilterLayout = QtGui.QHBoxLayout()
sourcesFilterLayout.addWidget(QtGui.QLabel("Filter:"))
sourcesFilterLayout.addWidget(sourcesFilterWidget)

class SourcesResultsWidget(QtGui.QTreeWidget):
  def __init__(self):
    QtGui.QTreeWidget.__init__(self)

    self.setIndentation(0)
    self.setHeaderLabels([
      "Filename",
      "Directory"
      ])

    def currentItemChanged(newItem, oldItem):
      currentItem = self.currentItem()
      if currentItem:
        filename = currentItem.text(0)
        directory = currentItem.text(1)
        pathname = os.path.join(directory, filename)
        sourceCodeDisplayWidget.updateDisplay(pathname, 0)
    self.currentItemChanged.connect(currentItemChanged)
    
    self.setFilter("")

  def setFilter(self, text):
    self.__filter = text
    self.updateDisplay()

  def updateDisplay(self):
    # self.setSortingEnabled(False)
    self.clear()
    count = target.GetNumModules()
    for i in range(0, count):
      module = target.GetModuleAtIndex(i)
      compileUnitCount = module.GetNumCompileUnits()
      for j in range(0, compileUnitCount):
        compileUnit = module.GetCompileUnitAtIndex(j)
        fileSpec = compileUnit.GetFileSpec()
        filename = fileSpec.GetFilename()
        directory = fileSpec.GetDirectory()
        if len(self.__filter) == 0 or self.__filter in filename or self.__filter in directory:
          tableWidgetItem = QtGui.QTreeWidgetItem()
          tableWidgetItem.setText(0, filename)
          tableWidgetItem.setText(1, directory)
          self.addTopLevelItem(tableWidgetItem)
    # self.setSortingEnabled(True)
    self.sortByColumn(0, QtCore.Qt.AscendingOrder)

sourcesResultsWidget = SourcesResultsWidget()
sourcesFilterWidget.filterChanged.connect(sourcesResultsWidget.setFilter)

sourcesLayout = QtGui.QVBoxLayout()
sourcesLayout.addLayout(sourcesFilterLayout)
sourcesLayout.addWidget(sourcesResultsWidget)

sourcesWidget = QtGui.QWidget()
sourcesWidget.setLayout(sourcesLayout)

class LLDBDisplay(AppendingTextWidget):
  def __init__(self):
    AppendingTextWidget.__init__(self)

    self.__commandColor = QtGui.QColor(QtCore.Qt.blue).lighter(50)
    self.__successOutputColor = QtGui.QColor(QtCore.Qt.green).lighter(50)
    self.__failureOutputColor = QtGui.QColor(QtCore.Qt.green).lighter(50)

  def appendCommand(self, text):
    self.append("> " + text + "\n", self.__commandColor)

  def appendDebuggerOutput(self, text):
    self.append(text, self.__successOutputColor)

  def appendDebuggerErrorOutput(self, text):
    self.append(text, self.__failureOutputColor)

lldbDisplay = LLDBDisplay()

class LLDBCommandWidget(QtGui.QLineEdit):
  def __init__(self, commandInterpreter, lldbDisplay):
    QtGui.QLineEdit.__init__(self)

    self.__commandInterpreter = commandInterpreter
    self.__lldbDisplay = lldbDisplay
    self.__lastCommand = None

    self.setFont(font)

    def returnPressedCallback():
      command = str(self.text())
      self.clear()
      if len(command) == 0 and self.__lastCommand != None:
        command = self.__lastCommand
      self.executeCommand(command)
    self.returnPressed.connect(returnPressedCallback)

  def executeCommand(self, command):
    lldbDisplay.appendCommand(command)
    return_obj = lldb.SBCommandReturnObject()
    self.__commandInterpreter.HandleCommand(command, return_obj)
    if return_obj.Succeeded():
      self.__lldbDisplay.appendDebuggerOutput(return_obj.GetOutput())
    else:
      self.__lldbDisplay.appendDebuggerErrorOutput(return_obj.GetError())
    self.__lastCommand = command
    stackWidget.updateDisplay(target.GetProcess())

lldbCommandWidget = LLDBCommandWidget(
  debugger.GetCommandInterpreter(),
  lldbDisplay
  )

lldbCommandLayout = QtGui.QHBoxLayout()
lldbCommandLayout.addWidget(QtGui.QLabel("lldb:"))
lldbCommandLayout.addWidget(lldbCommandWidget)

lldbLayout = QtGui.QVBoxLayout()
lldbLayout.addWidget(lldbDisplay)
lldbLayout.addLayout(lldbCommandLayout)

lldbWidget = QtGui.QWidget()
lldbWidget.setLayout(lldbLayout)

stackWidget_dockWidget = QtGui.QDockWidget()
stackWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
stackWidget_dockWidget.setWindowTitle("Stack")
stackWidget_dockWidget.setWidget(stackWidget)

threadsWidget_dockWidget = QtGui.QDockWidget()
threadsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
threadsWidget_dockWidget.setWindowTitle("Threads")
threadsWidget_dockWidget.setWidget(threadsWidget)

# sourceCodeDisplayWidget_dockWidget = QtGui.QDockWidget()
# sourceCodeDisplayWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
# sourceCodeDisplayWidget_dockWidget.setWindowTitle("Source Code")
# sourceCodeDisplayWidget_dockWidget.setWidget(sourceCodeDisplayWidget)

lldbWidget_dockWidget = QtGui.QDockWidget()
lldbWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
lldbWidget_dockWidget.setWindowTitle("LLDB")
lldbWidget_dockWidget.setWidget(lldbWidget)

disassemblyDisplayWidget_dockWidget = QtGui.QDockWidget()
disassemblyDisplayWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
disassemblyDisplayWidget_dockWidget.setWindowTitle("Disassembly")
disassemblyDisplayWidget_dockWidget.setWidget(disassemblyDisplayWidget)

localsWidget_dockWidget = QtGui.QDockWidget()
localsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
localsWidget_dockWidget.setWindowTitle("Locals")
localsWidget_dockWidget.setWidget(localsWidget)

registersWidget_dockWidget = QtGui.QDockWidget()
registersWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
registersWidget_dockWidget.setWindowTitle("Registers")
registersWidget_dockWidget.setWidget(registersWidget)

outputWidget_dockWidget = QtGui.QDockWidget()
outputWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
outputWidget_dockWidget.setWindowTitle("Output")
outputWidget_dockWidget.setWidget(outputWidget)

sourcesWidget_dockWidget = QtGui.QDockWidget()
sourcesWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
sourcesWidget_dockWidget.setWindowTitle("Sources")
sourcesWidget_dockWidget.setWidget(sourcesWidget)

class MainWindow(QtGui.QMainWindow):
  def __init__(self, executable):
    QtGui.QMainWindow.__init__(self)

    settings.beginGroup("MainWindow")
    self.resize(settings.value("size", QtCore.QSize(800, 600)))
    self.move(settings.value("pos", QtCore.QPoint(200, 200)))
    settings.endGroup()

    title = "%s: %s" % (app.applicationName(), executable)
    self.setWindowTitle(title)

  def closeEvent(self, event):
    settings.beginGroup("MainWindow")
    settings.setValue("size", self.size())
    settings.setValue("pos", self.pos())
    settings.endGroup()

runningActions = []
stoppedActions = []

toolBar = QtGui.QToolBar()
interruptAction = toolBar.addAction("Interrupt")

def interruptCallback():
  lldbCommandWidget.executeCommand("process interrupt")
interruptAction.triggered.connect(interruptCallback)
runningActions.append(interruptAction)

continueAction = toolBar.addAction("Continue")
def continueCallback():
  lldbCommandWidget.executeCommand("process continue")
continueAction.triggered.connect(continueCallback)
stoppedActions.append(continueAction)

stepInAction = toolBar.addAction("Step In")
def stepInCallback():
  lldbCommandWidget.executeCommand("thread step-in")
stepInAction.triggered.connect(stepInCallback)
stoppedActions.append(stepInAction)

stepOverAction = toolBar.addAction("Step Over")
def stepOverCallback():
  lldbCommandWidget.executeCommand("thread step-over")
stepOverAction.triggered.connect(stepOverCallback)
stoppedActions.append(stepOverAction)

stepOutAction = toolBar.addAction("Step Out")
def stepOutCallback():
  lldbCommandWidget.executeCommand("thread step-out")
stepOutAction.triggered.connect(stepOutCallback)
stoppedActions.append(stepOutAction)

mainWindow = MainWindow(executable)
mainWindow.setCentralWidget(sourceCodeDisplayWidget)
mainWindow.addToolBar(toolBar)
mainWindow.addDockWidget(QtCore.Qt.TopDockWidgetArea, localsWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.TopDockWidgetArea, registersWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.LeftDockWidgetArea, stackWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.LeftDockWidgetArea, threadsWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.RightDockWidgetArea, disassemblyDisplayWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.RightDockWidgetArea, sourcesWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.BottomDockWidgetArea, lldbWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.BottomDockWidgetArea, outputWidget_dockWidget)
mainWindow.show()

def handleDebuggerEvents():
  event = lldb.SBEvent()
  eventCount = 0
  while debugger.GetListener().GetNextEvent(event):
    eventCount += 1
    if event.GetBroadcaster().GetName() == "lldb.process":
      process = target.GetProcess()

      if process.IsValid():
        process_stdout = process.GetSTDOUT(1024)
        if process_stdout:
          outputWidget.appendStdout(process_stdout)
          while process_stdout:
            process_stdout = process.GetSTDOUT(1024)
            outputWidget.appendStdout(process_stdout)
        process_stderr = process.GetSTDERR(1024)
        if process_stderr:
          outputWidget.appendStderr(process_stderr)
          while process_stderr:
            process_stderr = process.GetSTDERR(1024)
            outputWidget.appendStderr(process_stderr)

      state = lldb.SBProcess.GetStateFromEvent(event)
      if state == lldb.eStateInvalid:
        # Not a state event
        print 'process event = %s' % (event)
      else:
        if state == lldb.eStateStopped:
          didSelectThread = False
          for thread in process:
            frame = thread.GetFrameAtIndex(0)
            shouldSelectThread = False
            shouldDisplay = False
            
            stopReason = thread.GetStopReason()
            # if self.verbose:
            #   desc = "tid = %#x pc = %#x " % (thread.GetThreadID(),frame.GetPC()),
            if stopReason == lldb.eStopReasonNone:
              pass
            elif stopReason == lldb.eStopReasonTrace:
              shouldSelectThread = True
              shouldDisplay = True
            elif stopReason == lldb.eStopReasonPlanComplete:
              shouldSelectThread = True
            # elif stopReason == lldb.eStopReasonThreadExiting:
            #   lldbDisplay.appendDebuggerOutput("Stop: thread exiting\n")
            elif stopReason == lldb.eStopReasonExec:
              shouldDisplay = True
            elif stopReason == lldb.eStopReasonInvalid:
              pass
            elif stopReason == lldb.eStopReasonException:
              shouldSelectThread = True
              shouldDisplay = True
            elif stopReason == lldb.eStopReasonBreakpoint:
              shouldSelectThread = True
              shouldDisplay = True
            elif stopReason == lldb.eStopReasonWatchpoint:
              shouldSelectThread = True
              shouldDisplay = True
            elif stopReason == lldb.eStopReasonSignal:
              shouldSelectThread = True
              shouldDisplay = True
            
            if shouldDisplay:
              lldbDisplay.appendDebuggerOutput("STOP %s\n" % thread.GetStopDescription(256))

            if shouldSelectThread and not didSelectThread:
              didSelectThread = process.SetSelectedThread(thread)
        elif state == lldb.eStateExited:
          exit_desc = process.GetExitDescription()
          if exit_desc:
            lldbDisplay.appendDebuggerOutput("Process %u exited with status %u: %s\n" % (process.GetProcessID(), process.GetExitStatus(), exit_desc))
          else:
            lldbDisplay.appendDebuggerOutput("Process %u exited with status %u\n" % (process.GetProcessID(), process.GetExitStatus()))
        elif state == lldb.eStateCrashed:
          lldbDisplay.appendDebuggerOutput("Process %u crashed" % process.GetProcessID())
        elif state == lldb.eStateDetached:
          lldbDisplay.appendDebuggerOutput("Process %u detached" % process.GetProcessID())
        elif state == lldb.eStateRunning:
          # process is running, don't say anything, we will always get one of these after resuming
          pass
        elif state == lldb.eStateUnloaded:
          lldbDisplay.appendDebuggerOutput("Process %u unloaded, this shouldn't happen!!!" % process.GetProcessID())
        elif state == lldb.eStateConnected:
          pass
        elif state == lldb.eStateAttaching:
          pass
        elif state == lldb.eStateLaunching:
          pass

      if process.GetState() == lldb.eStateStopped:
        for action in runningActions:
          action.setEnabled(False)
        for action in stoppedActions:
          action.setEnabled(True)
      else:
        for action in runningActions:
          action.setEnabled(True)
        for action in stoppedActions:
          action.setEnabled(False)
    else:
      print 'Non-process event = %s' % (event)
  if eventCount > 0:
    threadsWidget.updateDisplay(target.GetProcess())
    sourcesResultsWidget.updateDisplay()

timer = QtCore.QTimer()
timer.timeout.connect(handleDebuggerEvents)
timer.start(100)

lldbDisplay.appendDebuggerOutput("Welcome to zBug version %s!\n" % app.applicationVersion())
if len(arguments) > 0:
  lldbCommandWidget.executeCommand(
    "settings set target.run-args -- %s" % (" ".join(map(lambda arg: ("\"%s\"" % arg), arguments)))
    )
lldbCommandWidget.executeCommand(
  "process launch --stop-at-entry"
  )
lldbCommandWidget.setFocus()

sys.exit(app.exec_())


