#!/usr/bin/env python

import sys, os, platform, commands, stat, signal, optparse
import json, select, socket
from PySide import QtCore, QtGui

zBugPath = os.path.dirname(os.path.realpath(sys.argv[0]))

config = {
  # assume that we're debugging a Fabric app and try to connect
  'connectFabric': True,

  # do some limited client-side interpretation for Fabric types
  'interpretFabriregTypes': True,
}

# must use optparse over argparse to support python 2.6
parser = optparse.OptionParser(usage="Usage: zBug [options] [<executable> [<arg> ...]]")
parser.disable_interspersed_args()
parser.add_option("-p", "--pid", dest="pid",
                  help="attach to running process with pid PID", metavar="PID")
(options, arguments) = parser.parse_args()

#----------------------------------------------------------------------
# Code that auto imports LLDB (from LLDB source code)
#----------------------------------------------------------------------
try:
  # Just try for LLDB in case PYTHONPATH is already correctly setup
  import lldb
except ImportError:
  lldb_python_dirs = list()
  # lldb is not in the PYTHONPATH, try some defaults for the current platform
  platform_system = platform.system()
  if platform_system == 'Darwin':
    # On Darwin, try the currently selected Xcode directory
    xcode_dir = commands.getoutput("xcode-select --print-path")
    if xcode_dir:
      lldb_python_dirs.append(os.path.realpath(xcode_dir + '/../SharedFrameworks/LLDB.framework/Resources/Python'))
      lldb_python_dirs.append(xcode_dir + '/Library/PrivateFrameworks/LLDB.framework/Resources/Python')
    lldb_python_dirs.append('/System/Library/PrivateFrameworks/LLDB.framework/Resources/Python')
  success = False
  for lldb_python_dir in lldb_python_dirs:
    if os.path.exists(lldb_python_dir):
      if not (sys.path.__contains__(lldb_python_dir)):
        sys.path.append(lldb_python_dir)
        try:
          import lldb
        except ImportError:
          pass
        else:
          success = True
          break
  if not success:
    print "error: couldn't locate the 'lldb' module, please set PYTHONPATH correctly"
    sys.exit(1)

class Debugger(QtCore.QObject):

  targetChanged = QtCore.Signal(lldb.SBTarget)
  processChanged = QtCore.Signal(lldb.SBProcess)
  processRunning = QtCore.Signal(lldb.SBProcess)
  processStopped = QtCore.Signal(lldb.SBProcess)
  processExited = QtCore.Signal(lldb.SBProcess)
  processAppendedToStdout = QtCore.Signal(basestring)
  processAppendedToStderr = QtCore.Signal(basestring)
  threadChanged = QtCore.Signal(lldb.SBThread)
  frameChanged = QtCore.Signal(lldb.SBFrame)

  def __init__(self):
    QtCore.QObject.__init__(self)

    self.__debugger = lldb.SBDebugger.Create()
    self.__debugger.SetAsync(True)

    self.__target = None
    self.__process = None
    self.__thread = None
    self.__frame = None

    # [andrew 20140124] for LLDB's own logging messages, enabling different types of these
    # is done via the console using "log enable <type> <subtype/all>"
    def logToStdout(msg):
      sys.stdout.write(msg)
      sys.stdout.flush()
    self.__debugger.SetLoggingCallback(logToStdout)

  def commandInterpreter(self):
    return self.__debugger.GetCommandInterpreter()

  def target(self):
    return self.__target

  def process(self):
    return self.__process

  def thread(self):
    return self.__thread

  def frame(self):
    return self.__frame

  def setFrame(self, frameIndex):
    frame = self.__thread.SetSelectedFrame(frameIndex)
    frameChanged = frame != self.__frame
    self.__frame = frame
    if frameChanged:
      self.frameChanged.emit(frame)

  def handleEvents(self):
    event = lldb.SBEvent()
    listener = self.__debugger.GetListener()
    while listener.GetNextEvent(event):
      # stream = lldb.SBStream()
      # event.GetDescription(stream)
      # print stream.GetData()

      if event.GetBroadcaster().GetName() == "lldb.process":
        target = self.__debugger.GetSelectedTarget()
        targetChanged = self.__target != target
        self.__target = target
        if targetChanged:
          self.__process = None
          self.__thread = None
          self.__frame = None

        process = target.GetProcess()
        processChanged = self.__process != process
        self.__process = process
        if processChanged:
          self.__thread = None
          self.__frame = None

        process_stdout = process.GetSTDOUT(1024)
        if process_stdout:
          self.processAppendedToStdout.emit(process_stdout)
          while process_stdout:
            process_stdout = process.GetSTDOUT(1024)
            self.processAppendedToStdout.emit(process_stdout)
        process_stderr = process.GetSTDERR(1024)
        if process_stderr:
          self.processAppendedToStderr.emit(process_stderr)
          while process_stderr:
            process_stderr = process.GetSTDERR(1024)
            self.processAppendedToStderr.emit(process_stderr)

        threadChanged = False
        frameChanged = False
        processStopped = False
        processRunning = False
        processExited = False
        state = lldb.SBProcess.GetStateFromEvent(event)
        if state == lldb.eStateInvalid:
          # Not a state event
          print 'process event = %s' % (event)
        else:
          if state == lldb.eStateStopped:
            didSelectThread = False
            for thread in process:
              frame = thread.GetFrameAtIndex(0)

              shouldSelectThread = False
              shouldDisplay = False

              stopReason = thread.GetStopReason()
              # if self.verbose:
              #   desc = "tid = %#x pc = %#x " % (thread.GetThreadID(),frame.GetPC()),
              if stopReason == lldb.eStopReasonNone:
                pass
              elif stopReason == lldb.eStopReasonTrace:
                shouldSelectThread = True
                shouldDisplay = True
              elif stopReason == lldb.eStopReasonPlanComplete:
                shouldSelectThread = True
              # elif stopReason == lldb.eStopReasonThreadExiting:
              #   lldbDisplay.appendDebuggerOutput("Stop: thread exiting\n")
              elif stopReason == lldb.eStopReasonExec:
                shouldDisplay = True
              elif stopReason == lldb.eStopReasonInvalid:
                pass
              elif stopReason == lldb.eStopReasonException:
                shouldSelectThread = True
                shouldDisplay = True
              elif stopReason == lldb.eStopReasonBreakpoint:
                shouldSelectThread = True
                shouldDisplay = True
              elif stopReason == lldb.eStopReasonWatchpoint:
                shouldSelectThread = True
                shouldDisplay = True
              elif stopReason == lldb.eStopReasonSignal:
                shouldSelectThread = True
                shouldDisplay = True

              if shouldDisplay:
                lldbDisplay.appendDebuggerOutput("STOP %s\n" % thread.GetStopDescription(256))

              if shouldSelectThread and not didSelectThread:
                threadChanged = self.__thread != thread
                self.__thread = thread

                frameChanged = self.__frame != frame
                self.__frame = frame

                didSelectThread = True
            processStopped = True
          elif state == lldb.eStateExited:
            processExited = True
            exit_desc = process.GetExitDescription()
            if exit_desc:
              lldbDisplay.appendDebuggerOutput("Process %u exited with status %u: %s\n" % (process.GetProcessID(), process.GetExitStatus(), exit_desc))
            else:
              lldbDisplay.appendDebuggerOutput("Process %u exited with status %u\n" % (process.GetProcessID(), process.GetExitStatus()))
          elif state == lldb.eStateCrashed:
            lldbDisplay.appendDebuggerOutput("Process %u crashed" % process.GetProcessID())
          elif state == lldb.eStateDetached:
            lldbDisplay.appendDebuggerOutput("Process %u detached" % process.GetProcessID())
          elif state == lldb.eStateRunning:
            processRunning = True
          elif state == lldb.eStateUnloaded:
            lldbDisplay.appendDebuggerOutput("Process %u unloaded, this shouldn't happen!!!" % process.GetProcessID())
          elif state == lldb.eStateConnected:
            pass
          elif state == lldb.eStateAttaching:
            pass
          elif state == lldb.eStateLaunching:
            pass

        if targetChanged:
          self.targetChanged.emit(self.__target)
        if processChanged:
          self.processChanged.emit(self.__process)
        if threadChanged:
          self.threadChanged.emit(self.__thread)
        if frameChanged:
          self.frameChanged.emit(self.__frame)
        if processStopped:
          self.processStopped.emit(self.__process)
        if processRunning:
          self.processRunning.emit(self.__process)
        if processExited:
          self.processExited.emit(self.__process)
      else:
        print 'Non-process event = %s' % (event)

debugger = Debugger()

app = QtGui.QApplication([])
app.setOrganizationName("zBug")
app.setApplicationName("zBug")
app.setApplicationVersion("1.1")

settings = QtCore.QSettings()

class Preferences(QtCore.QObject):

  class Dialog(QtGui.QDialog):

    def __init__(self, parent, preferences):
      QtGui.QDialog.__init__(self, parent)

      self.__preferences = preferences

      gridLayout = QtGui.QGridLayout()

      fixedFont = preferences.fixedFont()
      gridLayout.addWidget(QtGui.QLabel("Fixed-width font:"), 0, 0)
      self.__fixedFontDescLabel = QtGui.QLabel(fixedFont.toString())
      self.__fixedFontDescLabel.setFont(fixedFont)
      gridLayout.addWidget(self.__fixedFontDescLabel, 0, 1)
      changeFixedFontButton = QtGui.QPushButton("Change")
      changeFixedFontButton.clicked.connect(self.changeFixedFont)
      gridLayout.addWidget(changeFixedFontButton, 0, 2)

      layout = QtGui.QVBoxLayout()
      layout.addLayout(gridLayout)
      closeButton = QtGui.QPushButton("Close")
      closeButton.clicked.connect(self.hide)
      layout.addWidget(closeButton)
    
      self.setLayout(layout)

    def changeFixedFont(self):
      (newFixedFont, ok) = QtGui.QFontDialog.getFont(self.__preferences.fixedFont(), self)
      if ok:
        self.__preferences.setFixedFont(newFixedFont)
        self.__fixedFontDescLabel.setText(newFixedFont.toString())
        self.__fixedFontDescLabel.setFont(newFixedFont)

  def __init__(self, settings):
    QtCore.QObject.__init__(self)

    self.__settings = settings
    self.__dialog = None

    self.__fixedFont = QtGui.QFont()
    fixedFontString = settings.value("fixedFont")
    if fixedFontString:
      self.__fixedFont.fromString(fixedFontString)
    else:
      self.__fixedFont.setFamily("Monospace")
      self.__fixedFont.setStyleHint(QtGui.QFont.TypeWriter)
      self.__fixedFont.setPointSize(10)

  fixedFontChanged = QtCore.Signal(QtGui.QFont)

  def fixedFont(self):
    return self.__fixedFont

  def setFixedFont(self, fixedFont):
    self.__fixedFont = fixedFont
    settings.setValue("fixedFont", fixedFont.toString())
    self.fixedFontChanged.emit(fixedFont)

  def showDialog(self, parent):
    if not self.__dialog:
      self.__dialog = Preferences.Dialog(parent, self)
    self.__dialog.show()
    self.__dialog.raise_()
    self.__dialog.activateWindow()

  def settings(self):
    return self.__settings

preferences = Preferences(settings)

fabricSourceCode = {}

class LineNumberArea(QtGui.QWidget):
  def __init__(self, sourceWidget):
    QtGui.QWidget.__init__(self, sourceWidget)
    self.__sourceWidget = sourceWidget

  def sizeHint(self):
    return QtCore.QSize(self.__sourceWidget.lineNumberAreaWidth(), 0)

  def paintEvent(self, event):
    self.__sourceWidget.lineNumberAreaPaintEvent(event)

  def mousePressEvent(self, event):
    self.__sourceWidget.lineNumberAreaClickEvent(event)

class CodeDisplayWidget(QtGui.QPlainTextEdit):
  def __init__(self):
    QtGui.QPlainTextEdit.__init__(self)

    self.setReadOnly(True)
    self.setFont(preferences.fixedFont())
    preferences.fixedFontChanged.connect(self.setFont)
    self.setCenterOnScroll(True)

    lineNumberArea = LineNumberArea(self)
    self.__lineNumberArea = lineNumberArea

    self.__marginLabels = [" "]
    self.__maxMarginLabelLen = 1

    def updateLineNumberArea(rect, dy):
      if dy != 0:
        lineNumberArea.scroll(0, dy)
      else:
        lineNumberArea.update(0, rect.y(), lineNumberArea.width(), rect.height())

      if rect.contains(self.viewport().rect()):
        self.updateLineNumberAreaWidth()
    self.updateRequest.connect(updateLineNumberArea)

  def resizeEvent(self, event):
    QtGui.QWidget.resizeEvent(self, event)
    cr = self.contentsRect()
    self.__lineNumberArea.setGeometry(
      QtCore.QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height())
      )

  def lineNumberAreaWidth(self):
    return 3 + self.fontMetrics().width('X') * self.__maxMarginLabelLen + 3

  def updateLineNumberAreaWidth(self):
    self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

  def lineNumberAreaClickEvent(self, event):
    pass

  def lineNumberAreaPaintEvent(self, event):
    lineNumberArea = self.__lineNumberArea
    painter = QtGui.QPainter(lineNumberArea)
    painter.fillRect(event.rect(), QtCore.Qt.lightGray)
    block = self.firstVisibleBlock()
    blockNumber = block.blockNumber()
    top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
    bottom = top + int(self.blockBoundingRect(block).height())
    while block.isValid() and top <= event.rect().bottom():
      if block.isVisible() and bottom >= event.rect().top():
        marginLabel = self.__marginLabels[blockNumber]
        painter.setPen(QtCore.Qt.black)
        painter.drawText(
          0, top,
          lineNumberArea.width() - 3, self.fontMetrics().height(),
          QtCore.Qt.AlignRight, marginLabel
          )
      block = block.next()
      top = bottom
      bottom = top + int(self.blockBoundingRect(block).height())
      blockNumber = blockNumber + 1

  def highlightLine(self, lineNumber):
    document = self.document()
    block = document.findBlockByLineNumber(lineNumber)
    textCursor = self.textCursor()
    textCursor.setPosition(block.position())
    self.setTextCursor(textCursor)

    selection = QtGui.QTextEdit.ExtraSelection()
    lineColor = QtGui.QColor(QtCore.Qt.yellow).lighter(160)
    selection.format.setBackground(lineColor)
    selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
    selection.cursor = textCursor
    selection.cursor.clearSelection()
    self.setExtraSelections([selection]);

  def setContents(self, contents):
    self.__marginLabels = []
    self.__maxMarginLabelLen = 1
    self.clear()
    if len(contents) == 0:
      contents = [[" ", ""]]
    for contentItem in contents:
      self.__marginLabels.append(contentItem[0])
      marginLabelLen = len(contentItem[0])
      if marginLabelLen > self.__maxMarginLabelLen:
        self.__maxMarginLabelLen = marginLabelLen
      self.appendPlainText(contentItem[1])
    self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

class SourceWidget(QtGui.QWidget):

  class CodeWidget(QtGui.QPlainTextEdit):

    def __init__(self, debugger):
      QtGui.QPlainTextEdit.__init__(self)

      self.setFocusPolicy(QtCore.Qt.NoFocus)
      self.setMinimumSize(40, 30)

      self.__pathname = None

      self.setReadOnly(True)
      self.setFont(preferences.fixedFont())
      preferences.fixedFontChanged.connect(self.setFont)
      self.setCenterOnScroll(True)

      lineNumberArea = LineNumberArea(self)
      self.__lineNumberArea = lineNumberArea

      self.__highlightLine = 0
      self.__breakpointLines = []

      def updateLineNumberAreaWidth(newBlockCount):
        self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)
      self.blockCountChanged.connect(updateLineNumberAreaWidth)

      def updateLineNumberArea(rect, dy):
        if dy != 0:
          lineNumberArea.scroll(0, dy)
        else:
          lineNumberArea.update(0, rect.y(), lineNumberArea.width(), rect.height())

        if rect.contains(self.viewport().rect()):
          updateLineNumberAreaWidth(0)
      self.updateRequest.connect(updateLineNumberArea)

      updateLineNumberAreaWidth(0)

      self.__breakpointsWidget = None
      self.updateDisplay("", 0)

      debugger.frameChanged.connect(self.frameChanged)

    def pathname(self):
      return self.__pathname

    def resizeEvent(self, event):
      QtGui.QWidget.resizeEvent(self, event)
      cr = self.contentsRect()
      self.__lineNumberArea.setGeometry(
        QtCore.QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height())
        )

    def lineNumberAreaWidth(self):
      digits = 1
      max = self.blockCount()
      if max < 1:
        max = 1
      while max >= 10:
        max = max / 10
        digits = digits + 1
      return 3 + self.fontMetrics().width('9') * digits + 3

    def setBreakpointsWidget(self, widget):
      self.__breakpointsWidget = widget

    def lineNumberAreaClickEvent(self, event):
      firstBlock = self.firstVisibleBlock()
      blockHeight = self.blockBoundingRect(firstBlock).height()
      blockNum = int(event.y() / blockHeight) + firstBlock.blockNumber()
      lineNum = blockNum+1
      if self.__breakpointsWidget is not None:
        self.__breakpointsWidget.toggleBreakpoint(self.__pathname, lineNum)

    def lineNumberAreaPaintEvent(self, event):
      lineNumberArea = self.__lineNumberArea
      painter = QtGui.QPainter(lineNumberArea)
      painter.fillRect(event.rect(), QtCore.Qt.lightGray)
      block = self.firstVisibleBlock()
      blockNumber = block.blockNumber()
      top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
      bottom = top + int(self.blockBoundingRect(block).height())
      while block.isValid() and top <= event.rect().bottom():
        if block.isVisible() and bottom >= event.rect().top():
          blockNumberText = str(blockNumber + 1)
          painter.setPen(QtCore.Qt.black)
          painter.drawText(
            0, top,
            lineNumberArea.width() - 3, self.fontMetrics().height(),
            QtCore.Qt.AlignRight, blockNumberText
            )
        block = block.next()
        top = bottom
        bottom = top + int(self.blockBoundingRect(block).height())
        blockNumber = blockNumber + 1

    def markBreakpointLines(self, lines):
      self.__breakpointLines = lines
      self.addHighlights()

    def highlightLine(self, lineNumber):
      self.__highlightLine = lineNumber
      self.addHighlights()

    def addHighlights(self):
      selections = []
      document = self.document()

      for lineNumber in self.__breakpointLines:
        block = document.findBlockByLineNumber(lineNumber)
        textCursor = self.textCursor()
        textCursor.setPosition(block.position())
        self.setTextCursor(textCursor)

        selection = QtGui.QTextEdit.ExtraSelection()
        lineColor = QtGui.QColor(QtCore.Qt.red).lighter(160)
        selection.format.setBackground(lineColor)
        selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
        selection.cursor = textCursor
        selection.cursor.clearSelection()
        selections.append(selection)

      if self.__highlightLine > 0:
        block = document.findBlockByLineNumber(self.__highlightLine)
        textCursor = self.textCursor()
        textCursor.setPosition(block.position())
        self.setTextCursor(textCursor)

        selection = QtGui.QTextEdit.ExtraSelection()
        lineColor = QtGui.QColor(QtCore.Qt.yellow).lighter(160)
        selection.format.setBackground(lineColor)
        selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
        selection.cursor = textCursor
        selection.cursor.clearSelection()
        selections.append(selection)

      self.setExtraSelections(selections)

    def updateDisplay(self, pathname, lineNumber):
      newPathname = self.__pathname != self.pathname
      self.__pathname = pathname

      if len(pathname) > 0:
        if newPathname:
          contents = None
          if config['connectFabric']:
            if pathname.find("(internal)") != -1:
              contents = "Internal KL function, no source code available."
            elif fabricSourceCode.has_key(pathname):
              contents = fabricSourceCode[pathname]
            elif fabricSourceCode.has_key(os.path.basename(pathname)):
              contents = fabricSourceCode[os.path.basename(pathname)]

          if contents is None:
            try:
              f = open(pathname, 'r')
              contents = f.read()
              f.close()
            except IOError as e:
              contents = "Unable to read file:\n  %s\n" % str(e)
              lineNumber = 0
          self.setPlainText(contents)
      else:
        self.setPlainText("No source code for this location")
        lineNumber = 0

      if lineNumber >= 1:
        self.highlightLine(lineNumber - 1)
      else:
        self.highlightLine(0)

      if self.__breakpointsWidget is not None:
        self.__breakpointsWidget.markBreakpoints()

    def frameChanged(self, frame):
      lineEntry = frame.GetLineEntry()
      fileSpec = lineEntry.GetFileSpec()
      if fileSpec.GetFilename():
        pathname = str(fileSpec)
      else:
        pathname = ""
      lineNumber = lineEntry.GetLine()
      self.updateDisplay(pathname, lineNumber)

  def __init__(self, debugger, lldbCommandWidget):
    QtGui.QWidget.__init__(self)

    toolBar = QtGui.QToolBar()
    toolBar.setIconSize(QtCore.QSize(20, 20))

    continueAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "continue.png")), "Continue")
    continueAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("process continue"))
    debugger.processRunning.connect(lambda: continueAction.setEnabled(False))
    debugger.processStopped.connect(lambda: continueAction.setEnabled(True))
    debugger.processExited.connect(lambda: continueAction.setEnabled(False))

    stepOverAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "step-over.png")), "Step Over")
    stepOverAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("thread step-over"))
    debugger.processRunning.connect(lambda: stepOverAction.setEnabled(False))
    debugger.processStopped.connect(lambda: stepOverAction.setEnabled(True))
    debugger.processExited.connect(lambda: stepOverAction.setEnabled(False))

    stepInAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "step-in.png")), "Step Into")
    stepInAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("thread step-in"))
    debugger.processRunning.connect(lambda: stepInAction.setEnabled(False))
    debugger.processStopped.connect(lambda: stepInAction.setEnabled(True))
    debugger.processExited.connect(lambda: stepInAction.setEnabled(False))

    stepOutAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "step-out.png")), "Step Out")
    stepOutAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("thread step-out"))
    debugger.processRunning.connect(lambda: stepOutAction.setEnabled(False))
    debugger.processStopped.connect(lambda: stepOutAction.setEnabled(True))
    debugger.processExited.connect(lambda: stepOutAction.setEnabled(False))

    self.__codeWidget = SourceWidget.CodeWidget(debugger)

    self.__statusBarLabel = QtGui.QLabel()

    statusBarLayout = QtGui.QHBoxLayout()
    statusBarLayout.addWidget(self.__statusBarLabel)

    statusBar = QtGui.QStatusBar()
    statusBar.setSizeGripEnabled(False)
    statusBar.setLayout(statusBarLayout)

    layout = QtGui.QVBoxLayout()
    layout.setContentsMargins(0, 0, 0, 0)
    layout.setSpacing(0)
    layout.addWidget(toolBar)
    layout.addWidget(self.__codeWidget)
    layout.addWidget(statusBar)
    self.setLayout(layout)

  def pathname(self):
    return self.__codeWidget.pathname()

  def markBreakpointLines(self, lines):
    self.__codeWidget.markBreakpointLines(lines)

  def setBreakpointsWidget(self, breakpointsWidget):
    self.__codeWidget.setBreakpointsWidget(breakpointsWidget)

  def updateDisplay(self, pathname, lineNumber):
    self.__codeWidget.updateDisplay(pathname, lineNumber)
    self.__statusBarLabel.setText(pathname)

  def setTitle(self, title):
    self.parent().setTitle(title)

  def saveState(self, settings):
    pass

  def restoreState(self, settings):
    pass

class ValueWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self, includeExtras):
    QtGui.QTreeWidgetItem.__init__(self)

    self.__value = None
    self.__expanded = False
    self.__childItems = {}
    self.__includeExtras = includeExtras

    self.setFlags(
      QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEditable
      )
    
    self.setFonts(preferences.fixedFont())
    preferences.fixedFontChanged.connect(self.setFonts)

    self.__dynamicColor = QtGui.QColor(QtCore.Qt.red).lighter(190)

  def setFonts(self, fixedFont):
    self.setFont(0, fixedFont)
    self.setFont(1, fixedFont)
    if self.__includeExtras:
      self.setFont(2, fixedFont)

  def setValue(self, value):
    self.__value = value

  def wasExpanded(self):
    if not self.__expanded:
      self.__expanded = True
      self.refresh()

  def wasCollapsed(self):
    if self.__expanded:
      self.__expanded = False
      while self.childCount() > 0:
        child = self.takeChild(0)
        child.setValue(None)

  def hasChanged(self):
    error = lldb.SBError()
    self.__value.SetValueFromCString(str(self.text(1)), error)
    self.refresh()

  def refresh(self):
    value = self.__value
    includeExtras = self.__includeExtras

    self.setText(0, value.GetName())

    typeName = value.GetTypeName()
    valueText = value.GetValue()
    summaryText = value.GetSummary()

    showChildren = True
    extraChildren = []
    if typeName is not None and config['interpretFabriregTypes']:
      if typeName == 'String':
        flags = value.GetChildMemberWithName('indFlagAndLength')
        u = value.GetChildMemberWithName('u')
        if int(flags.GetValue()) & 0x80000000:
          value = u.GetChildMemberWithName('ind').GetChildMemberWithName('dataPtr')
        else:
          value = u.GetChildMemberWithName('dir').GetChildMemberWithName('data')
        valueText = value.GetSummary()
        summaryText = ''
        showChildren = False
      elif '[]' in typeName:
        size = value.GetChildMemberWithName('size')
        elements = value.GetChildMemberWithName('elements')
        if size.IsValid() and elements.IsValid():
          size = size.GetValue()
          if not size is None:
            elemtype = elements.GetChildAtIndex(0).GetType()
            size = int(size)
            # limit max displayed array size
            if size > 1024:
              size = 1024
            for num in range(size):
              name = '['+str(num)+']'
              data = elements.GetPointeeData(num)
              elem = elements.CreateValueFromData(name, data, elemtype)
              extraChildren.append(elem)

    self.setText(1, valueText)
    if value.GetValueDidChange():
      self.setBackground(1, self.__dynamicColor)
    else:
      self.setBackground(1, self.background(0))

    if includeExtras:
      self.setText(2, summaryText)
      if value.GetValueDidChange():
        self.setBackground(2, self.__dynamicColor)
      else:
        self.setBackground(2, self.background(0))

    self.setText(3, typeName)

    if not showChildren:
      return

    childCount = value.GetNumChildren()
    if childCount > 0:
      self.setChildIndicatorPolicy(QtGui.QTreeWidgetItem.ShowIndicator)
    else:
      self.setChildIndicatorPolicy(QtGui.QTreeWidgetItem.DontShowIndicator)

    while self.childCount() > 0:
      topLevelItem = self.takeChild(0)
      topLevelItem.setValue(None)

    if self.__expanded:
      for i in range(0, childCount):
        childValue = value.GetChildAtIndex(i)
        childValueName = childValue.GetName()
        if childValueName is None:
          continue
        if childValueName in self.__childItems:
          childValueWidgetItem = self.__childItems[childValueName]
        else:
          childValueWidgetItem = ValueWidgetItem(self.__includeExtras)
          self.__childItems[childValueName] = childValueWidgetItem
        childValueWidgetItem.setValue(childValue)
        self.addChild(childValueWidgetItem)
        childValueWidgetItem.refresh()

      for c in extraChildren:
        childValueName = c.GetName()
        if childValueName in self.__childItems:
          childValueWidgetItem = self.__childItems[childValueName]
        else:
          childValueWidgetItem = ValueWidgetItem(self.__includeExtras)
          self.__childItems[childValueName] = childValueWidgetItem
        childValueWidgetItem.setValue(c)
        self.addChild(childValueWidgetItem)
        childValueWidgetItem.refresh()
       
      self.treeWidget().expandItem(self)

class TreeWidget(QtGui.QTreeWidget):
  def __init__(self, settingsName):
    QtGui.QTreeWidget.__init__(self)

    self.__settingsName = settingsName

  def restoreState(self, settings):
    self.header().restoreState(settings.value("%s/state" % self.__settingsName))

  def saveState(self, settings):
    settings.setValue("%s/state" % self.__settingsName, self.header().saveState())

class LocalsWidget(TreeWidget):
  def __init__(self):
    TreeWidget.__init__(self, "locals")

    self.__topLevelItems = {}

    self.setEnabled(False)
    self.setIndentation(12)
    self.setHeaderLabels([
      "Name",
      "Value",
      "Details",
      "Type"
    ])

    def itemExpanded(item):
      item.wasExpanded()
    self.itemExpanded.connect(itemExpanded)

    def itemCollapsed(item):
      item.wasCollapsed()
    self.itemCollapsed.connect(itemCollapsed)

    def itemWasDoubleClicked(item, column):
      if column == 1:
        self.editItem(item, column)
    self.itemDoubleClicked.connect(itemWasDoubleClicked)

    def itemHasChanged(item):
      item.hasChanged()
    self.itemChanged.connect(itemHasChanged)

  def setFrame(self, frame):
    enabled = False

    if frame and frame.IsValid():
      while self.topLevelItemCount() > 0:
        topLevelItem = self.takeTopLevelItem(0)
        topLevelItem.setValue(None)

      includeArguments = True
      includeLocals = True
      includeStatics = True
      in_scope_only = True
      variables = frame.GetVariables(
        includeArguments,
        includeLocals,
        includeStatics,
        in_scope_only
        )

      variableCount = variables.GetSize()
      for i in range(0, variableCount):
        value = variables.GetValueAtIndex(i)
        valueName = value.GetName()
        if valueName in self.__topLevelItems:
          valueWidgetItem = self.__topLevelItems[valueName]
        else:
          valueWidgetItem = ValueWidgetItem(True)
          self.__topLevelItems[valueName] = valueWidgetItem
        valueWidgetItem.setValue(value)
        self.addTopLevelItem(valueWidgetItem)
        valueWidgetItem.refresh()

      enabled = True

    self.setEnabled(enabled)

localsWidget = LocalsWidget()
localsWidget.setFocusPolicy(QtCore.Qt.NoFocus)
debugger.frameChanged.connect(localsWidget.setFrame)

class RegistersWidget(TreeWidget):

  def __init__(self):
    TreeWidget.__init__(self, "registers")

    self.__topLevelItems = {}

    self.setEnabled(False)
    self.setIndentation(12)
    self.setHeaderLabels([
      "Name",
      "Value"
    ])

    def itemExpanded(item):
      item.wasExpanded()
    self.itemExpanded.connect(itemExpanded)
    def itemCollapsed(item):
      item.wasCollapsed()
    self.itemCollapsed.connect(itemCollapsed)

  def setFrame(self, frame):
    enabled = False

    if frame and frame.IsValid():
      while self.topLevelItemCount() > 0:
        topLevelItem = self.takeTopLevelItem(0)
        topLevelItem.setValue(None)

      registers = frame.GetRegisters()
      count = registers.GetSize()
      for i in range(0, count):
        value = registers.GetValueAtIndex(i)
        valueName = value.GetName()
        if valueName in self.__topLevelItems:
          valueWidgetItem = self.__topLevelItems[valueName]
        else:
          valueWidgetItem = ValueWidgetItem(includeExtras=False)
          self.__topLevelItems[valueName] = valueWidgetItem
        valueWidgetItem.setValue(value)
        self.addTopLevelItem(valueWidgetItem)
        valueWidgetItem.refresh()

      enabled = True

    self.setEnabled(enabled)

registersWidget = RegistersWidget()
registersWidget.setFocusPolicy(QtCore.Qt.NoFocus)
debugger.frameChanged.connect(registersWidget.setFrame)

class StackWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self, frame):
    QtGui.QTreeWidgetItem.__init__(self)

    self.__frame = frame

    self.setFonts(preferences.fixedFont())
    preferences.fixedFontChanged.connect(self.setFonts)

    self.setTextAlignment(1, QtCore.Qt.AlignRight)

    self.setText(0, "%d" % frame.GetFrameID())
    self.setText(1, "%#x" % frame.GetPC())
    self.setText(2, "%s" % (frame.GetFunctionName()))

  def frame(self):
    return self.__frame

  def setFonts(self, fixedFont):
    self.setFont(0, fixedFont)
    self.setFont(1, fixedFont)
    self.setFont(2, fixedFont)

class StackWidget(TreeWidget):

  def __init__(self):
    TreeWidget.__init__(self, "stack")

    self.setEnabled(False)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(0)
    self.setHeaderLabels([
      "#",
      "PC",
      "Location"
    ])

  def syncToSelectedItem(self):
    frame = None
    currentItem = self.currentItem()
    if currentItem:
      frameIndex = self.indexOfTopLevelItem(currentItem)
      thread = debugger.thread()
      if thread:
        debugger.setFrame(frameIndex)

  def updateDisplay(self):
    self.setCurrentItem(None)
    enabled = False

    thread = debugger.thread()
    if thread and thread.IsValid():
      process = thread.GetProcess()
      if process.GetState() == lldb.eStateStopped:
        count = thread.GetNumFrames()
        if count > 0:
          selectedFrame = thread.GetSelectedFrame()
          selectedFrameID = selectedFrame.GetFrameID()

          try:
            self.currentItemChanged.disconnect()
          except:
            pass
          self.clear()

          for i in range(0, count):
            frame = thread.GetFrameAtIndex(i)
            stackWidgetItem = StackWidgetItem(frame)
            self.addTopLevelItem(stackWidgetItem)
            if frame.GetFrameID() == selectedFrameID:
              self.setCurrentItem(stackWidgetItem)

          self.resizeColumnToContents(0)
          self.resizeColumnToContents(1)

          self.currentItemChanged.connect(self.syncToSelectedItem)

          enabled = True

    self.setEnabled(enabled)

stackWidget = StackWidget()
stackWidget.setFocusPolicy(QtCore.Qt.NoFocus)
debugger.frameChanged.connect(stackWidget.updateDisplay)
debugger.processRunning.connect(lambda: stackWidget.setEnabled(False))
debugger.processStopped.connect(lambda: stackWidget.setEnabled(True))
debugger.processExited.connect(lambda: stackWidget.setEnabled(False))

class ThreadsWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self, thread):
    QtGui.QTreeWidgetItem.__init__(self)

    self.setFonts(preferences.fixedFont())
    preferences.fixedFontChanged.connect(self.setFonts)

    process = thread.GetProcess()
    frame = thread.GetFrameAtIndex(0)

    self.setText(0, "%u" % thread.GetIndexID())
    self.setText(1, "%#x" % thread.GetThreadID())
    self.setText(2, thread.GetName())
    locationDesc = "%s" % (frame.GetFunctionName())
    self.setText(3, locationDesc)

  def setFonts(self, fixedFont):
    self.setFont(0, fixedFont)
    self.setFont(1, fixedFont)
    self.setFont(2, fixedFont)
    self.setFont(3, fixedFont)

class ThreadsWidget(TreeWidget):
  def __init__(self, stackWidget):
    TreeWidget.__init__(self, "threads")

    self.__stackWidget = stackWidget

    self.setEnabled(False)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(0)
    self.setHeaderLabels([
      "#",
      "TID",
      "Name",
      "Location"
    ])

    def currentItemChanged(newItem, oldItem):
      currentItem = self.currentItem()
      if currentItem:
        threadIndex = self.indexOfTopLevelItem(currentItem)
        target = debugger.target()
        if target and target.IsValid():
          process = target.GetProcess()
          if process and process.IsValid and process.GetState() == lldb.eStateStopped:
            thread = process.GetThreadAtIndex(int(threadIndex))
            process.SetSelectedThread(thread)
            self.__stackWidget.updateDisplay()
    self.currentItemChanged.connect(currentItemChanged)

  def updateDisplay(self):
    self.setCurrentItem(None)
    self.__process = None
    enabled = False

    target = debugger.target()
    if target and target.IsValid():
      process = target.GetProcess()
      if process and process.IsValid() and process.GetState() == lldb.eStateStopped:
        self.__process = process

        count = process.GetNumThreads()
        selectedThread = process.GetSelectedThread()
        selectedThreadID = selectedThread.GetThreadID()

        self.clear()
        for i in range(0, count):
          thread = process.GetThreadAtIndex(i)
          threadWidgetItem = ThreadsWidgetItem(thread)
          self.addTopLevelItem(threadWidgetItem)
          if thread.GetThreadID() == selectedThreadID:
            self.setCurrentItem(threadWidgetItem)

        self.resizeColumnToContents(0)
        self.resizeColumnToContents(1)

        enabled = True
    self.setEnabled(enabled)

threadsWidget = ThreadsWidget(stackWidget)
threadsWidget.setFocusPolicy(QtCore.Qt.NoFocus)
debugger.processRunning.connect(threadsWidget.updateDisplay)
debugger.processStopped.connect(threadsWidget.updateDisplay)
debugger.processExited.connect(threadsWidget.updateDisplay)

class AppendingTextWidget(QtGui.QTextEdit):
  def __init__(self):
    QtGui.QTextEdit.__init__(self)

    self.setReadOnly(True)
    self.setFont(preferences.fixedFont())
    preferences.fixedFontChanged.connect(self.setFont)

  def append(self, text, color):
    self.setTextColor(color)
    charFormat = self.currentCharFormat()
    textCursor = self.textCursor()
    textCursor.movePosition(QtGui.QTextCursor.End)
    textCursor.insertText(text, charFormat)
    self.setTextCursor(textCursor)
    self.ensureCursorVisible()

class OutputWidget(AppendingTextWidget):
  def __init__(self, debugger):
    AppendingTextWidget.__init__(self)

    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setMinimumWidth(640)

    self.__stdoutColor = QtGui.QColor(QtCore.Qt.black)
    self.__stderrColor = QtGui.QColor(QtCore.Qt.red).lighter(50)

    debugger.processAppendedToStdout.connect(self.appendStdout)
    debugger.processAppendedToStderr.connect(self.appendStderr)

  def saveState(self, settings):
    pass

  def restoreState(self, settings):
    pass

  def appendStdout(self, text):
    self.append(text, self.__stdoutColor)

  def appendStderr(self, text):
    self.append(text, self.__stderrColor)

outputWidget = OutputWidget(debugger)

class NoFocusWidget(QtGui.QWidget):
  def __init__(self):
    QtGui.QWidget.__init__(self)

    self.setFocusPolicy(QtCore.Qt.NoFocus)

class SourcesWidget(NoFocusWidget):

  class FilterWidget(QtGui.QLineEdit):
    filterChanged = QtCore.Signal(basestring)

    def __init__(self):
      QtGui.QLineEdit.__init__(self)

      self.setFont(preferences.fixedFont())
      preferences.fixedFontChanged.connect(self.setFont)

      def returnPressed():
        text = self.text()
        self.selectAll()
        self.filterChanged.emit(text)
      self.returnPressed.connect(returnPressed)

    def restoreState(self, settings):
      self.setText(settings.value("sources/filter", ""))

    def saveState(self, settings):
      settings.setValue("sources/filter", self.text())

  class KLTypeWidget(QtGui.QCheckBox):
    def __init__(self):
      QtGui.QCheckBox.__init__(self, "KL")

      self.__settings = settings

    def restoreState(self, settings):
      checked = settings.value("sources/types/kl", False)
      if checked:
        self.setCheckState(QtCore.Qt.Checked)
      else:
        self.setCheckState(QtCore.Qt.Unchecked)

    def saveState(self, settings):
      checked = self.checkState() == QtCore.Qt.Checked
      settings.setValue("sources/types/kl", checked)

  class RegTypeWidget(QtGui.QCheckBox):
    def __init__(self):
      QtGui.QCheckBox.__init__(self, "Regular")

      self.__settings = settings

    def restoreState(self, settings):
      checked = settings.value("sources/types/reg", False)
      if checked:
        self.setCheckState(QtCore.Qt.Checked)
      else:
        self.setCheckState(QtCore.Qt.Unchecked)

    def saveState(self, settings):
      checked = self.checkState() == QtCore.Qt.Checked
      settings.setValue("sources/types/reg", checked)

  class ResultsWidget(TreeWidget):
    def __init__(self, filterWidget, regTypeWidget, klTypeWidget):
      TreeWidget.__init__(self, "sources")

      self.__filterWidget = filterWidget;
      self.__regTypeWidget = regTypeWidget;
      self.__klTypeWidget = klTypeWidget;

      self.setIndentation(0)

      self.setHeaderLabels([
        "Filename",
        "Directory"
        ])

      def currentItemChanged(newItem, oldItem):
        currentItem = self.currentItem()
        if currentItem:
          filename = currentItem.text(0)
          directory = currentItem.text(1)
          if len(directory) > 0:
            pathname = os.path.join(directory, filename)
          else:
            pathname = filename
          sourceWidget.updateDisplay(pathname, 0)
      self.currentItemChanged.connect(currentItemChanged)

    def updateDisplay(self):
      filterText = self.__filterWidget.text().strip()
      regType = self.__regTypeWidget.isChecked()
      klType = self.__klTypeWidget.isChecked()

      count = 0
      target = debugger.target()
      if target and target.IsValid():
        count = target.GetNumModules()

      self.clear()
      if klType:
        for filename in fabricSourceCode:
          if len(filterText) == 0 \
              or (filename is not None and filterText in filename):
            tableWidgetItem = QtGui.QTreeWidgetItem()
            tableWidgetItem.setText(0, filename)
            tableWidgetItem.setText(1, '')
            self.addTopLevelItem(tableWidgetItem)
      if regType:
        for i in range(0, count):
          module = target.GetModuleAtIndex(i)
          compileUnitCount = module.GetNumCompileUnits()
          for j in range(0, compileUnitCount):
            compileUnit = module.GetCompileUnitAtIndex(j)
            fileSpec = compileUnit.GetFileSpec()
            filename = fileSpec.GetFilename()
            if not filename:
              continue
            directory = fileSpec.GetDirectory()
            if len(filterText) == 0 \
                or (filename is not None and filterText in filename) \
                or (directory is not None and filterText in directory):
              tableWidgetItem = QtGui.QTreeWidgetItem()
              tableWidgetItem.setText(0, filename)
              tableWidgetItem.setText(1, directory)
              self.addTopLevelItem(tableWidgetItem)
      self.sortByColumn(0, QtCore.Qt.AscendingOrder)

  def __init__(self):
    NoFocusWidget.__init__(self)

    self.__regTypeWidget = self.RegTypeWidget()
    self.__klTypeWidget = self.KLTypeWidget()
    typeLayout = QtGui.QHBoxLayout()
    typeLayout.addWidget(QtGui.QLabel("Source types:"))
    typeLayout.addWidget(self.__regTypeWidget)
    typeLayout.addWidget(self.__klTypeWidget)

    self.__filterWidget = self.FilterWidget()

    filterLayout = QtGui.QGridLayout()
    filterLayout.addWidget(QtGui.QLabel("Filter:"), 0, 0)
    filterLayout.addWidget(self.__filterWidget, 0, 1)
    filterLayout.addLayout(typeLayout, 1, 1)

    self.__resultsWidget = self.ResultsWidget(
      self.__filterWidget,
      self.__regTypeWidget,
      self.__klTypeWidget
      )
    self.__resultsWidget.setFocusPolicy(QtCore.Qt.NoFocus)
    self.__filterWidget.filterChanged.connect(self.__resultsWidget.updateDisplay)
    self.__regTypeWidget.stateChanged.connect(self.__resultsWidget.updateDisplay)
    self.__klTypeWidget.stateChanged.connect(self.__resultsWidget.updateDisplay)

    layout = QtGui.QVBoxLayout()
    layout.addLayout(filterLayout)
    layout.addWidget(self.__resultsWidget)
    self.setLayout(layout)

    self.updateDisplay()

  def restoreState(self, settings):
    self.__regTypeWidget.restoreState(settings)
    self.__klTypeWidget.restoreState(settings)
    self.__filterWidget.restoreState(settings)

  def saveState(self, settings):
    self.__regTypeWidget.saveState(settings)
    self.__klTypeWidget.saveState(settings)
    self.__filterWidget.saveState(settings)

  def updateDisplay(self):
    self.__resultsWidget.updateDisplay()

sourcesWidget = SourcesWidget()
debugger.processStopped.connect(sourcesWidget.updateDisplay)

class LLDBDisplay(AppendingTextWidget):
  def __init__(self):
    AppendingTextWidget.__init__(self)

    self.__commandColor = QtGui.QColor(QtCore.Qt.blue).lighter(50)
    self.__successOutputColor = QtGui.QColor(QtCore.Qt.green).lighter(50)
    self.__failureOutputColor = QtGui.QColor(QtCore.Qt.green).lighter(50)

  def saveState(self, settings):
    pass

  def restoreState(self, settings):
    pass

  def appendCommand(self, text):
    self.append("> " + text + "\n", self.__commandColor)

  def appendDebuggerOutput(self, text):
    self.append(text, self.__successOutputColor)

  def appendDebuggerErrorOutput(self, text):
    self.append(text, self.__failureOutputColor)

class BreakpointsWidget(TreeWidget):
  class BP(object):
    def __init__(self, pathname, line):
      self.pathname = pathname
      self.line = line
    def __eq__(a, b):
      return a.pathname == b.pathname and a.line == b.line

  def __init__(self, sourceCodeDisplay):
    TreeWidget.__init__(self, "breakpoints")

    self.__breakpoints = {}
    self.__sourceWidget = sourceCodeDisplay

    self.setIndentation(12)
    self.setHeaderLabels([
      "ID",
      "Description",
    ])

    def itemWasClicked(item, column):
      bpid = int(item.text(0))
      # [andrew 20140123] applies for internal breakpoints, which we will hide next version
      if not self.__breakpoints.has_key(bpid):
        return
      bp = self.__breakpoints[bpid]
      self.__sourceWidget.updateDisplay(bp.pathname, bp.line)
      self.markBreakpoints()
    self.itemClicked.connect(itemWasClicked)

  def toggleBreakpoint(self, pathname, lineNum):
    # [andrew 20140123] FIXME incorrectly assume unique pathnames
    newvalue = BreakpointsWidget.BP(pathname, lineNum)
    if newvalue not in self.__breakpoints.values():
      bp = debugger.target().BreakpointCreateByLocation(str(pathname), int(lineNum))
      self.__breakpoints[bp.id] = newvalue
    else:
      for bpid, bpvalue in self.__breakpoints.iteritems():
        if newvalue == bpvalue:
          debugger.GetSelectedTarget().BreakpointDelete(bpid)
          del self.__breakpoints[bpid]
          break
    self.updateDisplay()

  def updateDisplay(self):
    self.clear()
    target = debugger.target()
    if target and target.IsValid():
      for bp in target.breakpoint_iter():
        item = QtGui.QTreeWidgetItem()
        item.setText(0, str(bp.id))
        item.setText(1, str(bp))
        self.addTopLevelItem(item)
    self.markBreakpoints()

  def markBreakpoints(self):
    lines = []
    # [andrew 20140123] FIXME incorrectly assume unique filenames
    currentPathname = self.__sourceWidget.pathname()
    for bpid, bp in self.__breakpoints.iteritems():
      if bp.pathname == currentPathname:
        lines.append(bp.line-1)
    self.__sourceWidget.markBreakpointLines(lines)

lldbDisplay = LLDBDisplay()
lldbDisplay.setFocusPolicy(QtCore.Qt.NoFocus)

class LLDBCommandWidget(QtGui.QLineEdit):
  def __init__(self, commandInterpreter, lldbDisplay):
    QtGui.QLineEdit.__init__(self)

    self.__commandInterpreter = commandInterpreter
    self.__lldbDisplay = lldbDisplay
    self.__history = []
    self.__historyPos = 0

    self.setFont(preferences.fixedFont())
    preferences.fixedFontChanged.connect(self.setFont)

    def returnPressedCallback():
      command = str(self.text())
      self.clear()
      if len(command) == 0 and len(self.__history) > 0:
        command = self.__history[len(self.__history)-1]
      self.executeCommand(command)
    self.returnPressed.connect(returnPressedCallback)

  def saveState(self, settings):
    pass

  def restoreState(self, settings):
    pass

  def event(self, event):
    if event.type() == QtCore.QEvent.Type.KeyPress:
      key = event.key()
      if key == QtCore.Qt.Key_Tab:
        text = str(self.text())
        stringList = lldb.SBStringList()
        self.__commandInterpreter.HandleCompletion(
          text, len(text), 1, -1, stringList
          )
        if stringList.GetSize() > 0:
          self.setText(text + stringList.GetStringAtIndex(0))
        return True
      elif key == QtCore.Qt.Key_Up:
        if self.__historyPos > 0:
          self.__historyPos -= 1
          self.setText(self.__history[self.__historyPos])
          self.selectAll()
          return True
      elif key == QtCore.Qt.Key_Down:
        if self.__historyPos < len(self.__history):
          self.__historyPos += 1
          if self.__historyPos == len(self.__history):
            self.setText("")
          else:
            self.setText(self.__history[self.__historyPos])
          self.selectAll()
          return True
    return QtGui.QLineEdit.event(self, event)

  def executeCommand(self, command):
    lldbDisplay.appendCommand(command)
    return_obj = lldb.SBCommandReturnObject()
    self.__commandInterpreter.HandleCommand(command, return_obj, True)
    if return_obj.Succeeded():
      self.__lldbDisplay.appendDebuggerOutput(return_obj.GetOutput())
    else:
      self.__lldbDisplay.appendDebuggerErrorOutput(return_obj.GetError())
    self.__history.append(command)
    self.__historyPos = len(self.__history)
    breakpointsWidget.updateDisplay()
    watchpointsWidget.updateDisplay()

lldbCommandWidget = LLDBCommandWidget(
  debugger.commandInterpreter(),
  lldbDisplay
  )

sourceWidget = SourceWidget(debugger, lldbCommandWidget)

breakpointsWidget = BreakpointsWidget(sourceWidget)
breakpointsWidget.setFocusPolicy(QtCore.Qt.NoFocus)
sourceWidget.setBreakpointsWidget(breakpointsWidget)

class DisassemblyWidget(QtGui.QWidget):

  class Code(CodeDisplayWidget):
    def __init__(self):
      CodeDisplayWidget.__init__(self)

    def saveState(self, settings):
      pass

    def restoreState(self, settings):
      pass

    def frame(self):
      return self.__frame

    def setFrame(self, frame):
      self.__frame = frame
      pc = frame.GetPC()
      pcAddress = frame.GetPCAddress()

      thread = frame.GetThread()
      process = thread.GetProcess()
      target = process.GetTarget()

      function = frame.GetFunction()
      if function:
        instructions = function.GetInstructions(target)
      else:
        symbol = frame.GetSymbol()
        if symbol:
          instructions = symbol.GetInstructions(target)
        else:
          data = lldb.SBData()
          error = lldb.SBError()
          data = bytearray(frame.GetThread().GetProcess().ReadMemory(pc, 1024, error))
          instructions = target.GetInstructions(pcAddress, data)

      self.clear()
      count = instructions.GetSize()
      contents = []
      lineCount = 0
      lineNumberToHighlight = None
      for i in range(0, count):
        instruction = instructions.GetInstructionAtIndex(i)
        address = instruction.GetAddress()
        loadAddress = address.GetLoadAddress(target)
        if loadAddress < pc - 256 or loadAddress > pc + 256:
          continue
        if loadAddress == pc:
          lineNumberToHighlight = lineCount
        mnemonic = instruction.GetMnemonic(target)
        operands =  instruction.GetOperands(target)
        comment =  instruction.GetComment(target)
        desc = "%-8s %s" % (mnemonic, operands)
        if comment:
          if len(desc) < 32:
            desc += ' ' * (32 - len(desc))
          desc += "; %s" % comment
        contents.append(["%#x" % loadAddress, desc])
        lineCount += 1
      self.setContents(contents)

      if lineNumberToHighlight != None:
        self.highlightLine(lineNumberToHighlight)
      else:
        self.setExtraSelections([])

  def __init__(self, lldbCommandWidget):
    QtGui.QWidget.__init__(self)

    self.__code = DisassemblyWidget.Code()

    layout = QtGui.QVBoxLayout()
    layout.setContentsMargins(0, 0, 0, 0)
    layout.setSpacing(0)
    
    toolBar = QtGui.QToolBar()
    toolBar.setIconSize(QtCore.QSize(20, 20))

    continueAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "continue.png")), "Continue")
    continueAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("process continue"))
    debugger.processRunning.connect(lambda: continueAction.setEnabled(False))
    debugger.processStopped.connect(lambda: continueAction.setEnabled(True))
    debugger.processExited.connect(lambda: continueAction.setEnabled(False))

    stepOverAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "step-inst-over.png")), "Step Over Instruction")
    stepOverAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("thread step-inst-over"))
    debugger.processRunning.connect(lambda: stepOverAction.setEnabled(False))
    debugger.processStopped.connect(lambda: stepOverAction.setEnabled(True))
    debugger.processExited.connect(lambda: stepOverAction.setEnabled(False))

    stepInAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "step-inst.png")), "Step Into Instruction")
    stepInAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("thread step-inst"))
    debugger.processRunning.connect(lambda: stepInAction.setEnabled(False))
    debugger.processStopped.connect(lambda: stepInAction.setEnabled(True))
    debugger.processExited.connect(lambda: stepInAction.setEnabled(False))

    stepOutAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "step-out.png")), "Step Out")
    stepOutAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("thread step-out"))
    debugger.processRunning.connect(lambda: stepOutAction.setEnabled(False))
    debugger.processStopped.connect(lambda: stepOutAction.setEnabled(True))
    debugger.processExited.connect(lambda: stepOutAction.setEnabled(False))

    layout.addWidget(toolBar)

    layout.addWidget(self.__code)

    self.setLayout(layout)

  def frame(self):
    return self.__code.frame()

  def setFrame(self, frame):
    self.__code.setFrame(frame)

  def saveState(self, settings):
    self.__code.saveState(settings)

  def restoreState(self, settings):
    self.__code.restoreState(settings)

disassemblyWidget = DisassemblyWidget(lldbCommandWidget)
disassemblyWidget.setFocusPolicy(QtCore.Qt.NoFocus)
debugger.frameChanged.connect(disassemblyWidget.setFrame)

class WatchpointsWidget(QtGui.QWidget):

  class Item(QtGui.QTreeWidgetItem):
    def __init__(self, watchpoint):
      QtGui.QTreeWidgetItem.__init__(self)

      self.__watchpoint = watchpoint

      self.setFlags(
        QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEditable
        )
      self.setFonts(preferences.fixedFont())
      preferences.fixedFontChanged.connect(self.setFonts)

      self.setText(0, "%d" % watchpoint.GetID())
      self.setTextAlignment(1, QtCore.Qt.AlignRight)
      self.setText(1, "%#x" % watchpoint.GetWatchAddress())
      self.setText(2, "%d" % watchpoint.GetWatchSize())
      self.setText(3, "%d" % watchpoint.GetHitCount())
      self.setText(4, "%d" % watchpoint.GetIgnoreCount())
      condition = watchpoint.GetCondition()
      if condition:
        self.setText(5, condition)

    def setFonts(self, fixedFont):
      self.setFont(0, fixedFont)
      self.setFont(1, fixedFont)
      self.setFont(2, fixedFont)
      self.setFont(3, fixedFont)
      self.setFont(4, fixedFont)

    def hasChanged(self):
      self.__watchpoint.SetCondition(self.text(5))

  class List(TreeWidget):

    def __init__(self):
      TreeWidget.__init__(self, "watchpoints")

      self.setIndentation(12)
      self.setHeaderLabels([
        "ID",
        "Address",
        "Size",
        "Hits",
        "Igns",
        "Condition",
        ])

    def updateDisplay(self):
      self.clear()
      target = debugger.target()
      if target and target.IsValid():
        for i in range(0, target.GetNumWatchpoints()):
          watchpoint = target.GetWatchpointAtIndex(i)
          self.addTopLevelItem(WatchpointsWidget.Item(watchpoint))
      self.resizeColumnToContents(0)
      self.resizeColumnToContents(1)
      self.resizeColumnToContents(2)
      self.resizeColumnToContents(3)
      self.resizeColumnToContents(4)

  def __init__(self, lldbCommandWidget):
    QtGui.QWidget.__init__(self)

    self.__list = WatchpointsWidget.List()

    addVarLayout = QtGui.QHBoxLayout()
    addVarLayout.addWidget(QtGui.QLabel("Add watchpoint:"))
    addVarLineEdit = QtGui.QLineEdit()
    addVarLineEdit.setPlaceholderText("expression")
    def addVar():
      lldbCommandWidget.executeCommand(
        "watchpoint set expression -- %s" % str(addVarLineEdit.text())
        )
      addVarLineEdit.clear()
    addVarLineEdit.returnPressed.connect(addVar)
    addVarLayout.addWidget(addVarLineEdit)

    layout = QtGui.QVBoxLayout()
    layout.addLayout(addVarLayout)
    layout.addWidget(self.__list)

    self.setLayout(layout)

  def saveState(self, settings):
    self.__list.saveState(settings)

  def restoreState(self, settings):
    self.__list.restoreState(settings)

  def updateDisplay(self):
    self.__list.updateDisplay()

watchpointsWidget = WatchpointsWidget(lldbCommandWidget)
watchpointsWidget.setFocusPolicy(QtCore.Qt.NoFocus)

lldbCommandLayout = QtGui.QHBoxLayout()
lldbCommandLayout.setContentsMargins(4, 3, 4, 3)
lldbCommandLayout.setSpacing(4)
lldbCommandLayout.addWidget(QtGui.QLabel("lldb:"))
lldbCommandLayout.addWidget(lldbCommandWidget)

toolBar = QtGui.QToolBar()
toolBar.setIconSize(QtCore.QSize(20, 20))

restartAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "restart.png")), "Restart")
restartAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("process launch"))
debugger.processRunning.connect(lambda: restartAction.setEnabled(False))
debugger.processStopped.connect(lambda: restartAction.setEnabled(True))
debugger.processExited.connect(lambda: restartAction.setEnabled(True))

interruptAction = toolBar.addAction(QtGui.QIcon(os.path.join(zBugPath, "rsrc", "pause.png")), "Interrupt")
interruptAction.triggered.connect(lambda: lldbCommandWidget.executeCommand("process interrupt"))
debugger.processRunning.connect(lambda: interruptAction.setEnabled(True))
debugger.processStopped.connect(lambda: interruptAction.setEnabled(False))
debugger.processExited.connect(lambda: interruptAction.setEnabled(False))

lldbLayout = QtGui.QVBoxLayout()
lldbLayout.setContentsMargins(0, 0, 0, 0)
lldbLayout.setSpacing(0)
lldbLayout.addWidget(toolBar)
lldbLayout.addWidget(lldbDisplay)
lldbLayout.addLayout(lldbCommandLayout)

lldbWidget = QtGui.QWidget()
lldbWidget.setLayout(lldbLayout)

class MainWindow(QtGui.QMainWindow):
  def __init__(self, preferences):
    QtGui.QMainWindow.__init__(self)

    self.__settings = preferences.settings()

    menuBar = self.menuBar()

    fileMenu = QtGui.QMenu("&File")
    preferencesAction = fileMenu.addAction("Preferences")
    preferencesAction.triggered.connect(lambda: preferences.showDialog(self))
    fileMenu.addSeparator()
    exitAction = fileMenu.addAction("E&xit")
    exitAction.triggered.connect(self.close)
    menuBar.addMenu(fileMenu)

    def handler(signum, frame):
      signal.signal(signum, signal.SIG_DFL)
      self.close()
    signal.signal(signal.SIGINT, handler)

    self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtGui.QTabWidget.South)
    self.setDockNestingEnabled(True)

    localsWidget.restoreState(settings)
    localsWidget_dockWidget = QtGui.QDockWidget()
    localsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    localsWidget_dockWidget.setObjectName("Locals")
    localsWidget_dockWidget.setWindowTitle("Locals")
    localsWidget_dockWidget.setWidget(localsWidget)
    localsWidget_dockWidget.setHidden(False)
    self.addDockWidget(QtCore.Qt.TopDockWidgetArea, localsWidget_dockWidget)

    registersWidget.restoreState(settings)
    registersWidget_dockWidget = QtGui.QDockWidget()
    registersWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    registersWidget_dockWidget.setObjectName("Registers")
    registersWidget_dockWidget.setWindowTitle("Registers")
    registersWidget_dockWidget.setWidget(registersWidget)
    registersWidget_dockWidget.setHidden(True)
    self.addDockWidget(QtCore.Qt.TopDockWidgetArea, registersWidget_dockWidget)

    stackWidget.restoreState(settings)
    stackWidget_dockWidget = QtGui.QDockWidget()
    stackWidget_dockWidget.setObjectName("Stack")
    stackWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    stackWidget_dockWidget.setWindowTitle("Stack")
    stackWidget_dockWidget.setWidget(stackWidget)
    stackWidget_dockWidget.setHidden(False)
    self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, stackWidget_dockWidget)

    threadsWidget.restoreState(settings)
    threadsWidget_dockWidget = QtGui.QDockWidget()
    threadsWidget_dockWidget.setObjectName("Threads")
    threadsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    threadsWidget_dockWidget.setWindowTitle("Threads")
    threadsWidget_dockWidget.setWidget(threadsWidget)
    threadsWidget_dockWidget.setHidden(True)
    self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, threadsWidget_dockWidget)

    sourcesWidget.restoreState(settings)
    sourcesWidget_dockWidget = QtGui.QDockWidget()
    sourcesWidget_dockWidget.setObjectName("Sources")
    sourcesWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    sourcesWidget_dockWidget.setWindowTitle("Sources")
    sourcesWidget_dockWidget.setWidget(sourcesWidget)
    sourcesWidget_dockWidget.setHidden(True)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, sourcesWidget_dockWidget)

    sourceWidget.restoreState(settings)
    self.setCentralWidget(sourceWidget)
    # sourceWidget_dockWidget = QtGui.QDockWidget()
    # sourceWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    # sourceWidget_dockWidget.setObjectName("Source")
    # sourceWidget_dockWidget.setWindowTitle("Source")
    # sourceWidget_dockWidget.setWidget(sourceWidget)
    # sourceWidget_dockWidget.setHidden(False)
    # self.addDockWidget(QtCore.Qt.RightDockWidgetArea, sourceWidget_dockWidget)

    disassemblyWidget.restoreState(settings)
    disassemblyWidget_dockWidget = QtGui.QDockWidget()
    disassemblyWidget_dockWidget.setObjectName("Disassembly")
    disassemblyWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    disassemblyWidget_dockWidget.setWindowTitle("Disassembly")
    disassemblyWidget_dockWidget.setWidget(disassemblyWidget)
    disassemblyWidget_dockWidget.setHidden(True)
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, disassemblyWidget_dockWidget)

    # lldbWidget.restoreState(settings)
    lldbWidget_dockWidget = QtGui.QDockWidget()
    lldbWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    lldbWidget_dockWidget.setWindowTitle("LLDB")
    lldbWidget_dockWidget.setObjectName("LLDB")
    lldbWidget_dockWidget.setWidget(lldbWidget)
    lldbWidget_dockWidget.setHidden(False)
    self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, lldbWidget_dockWidget)

    outputWidget.restoreState(settings)
    outputWidget_dockWidget = QtGui.QDockWidget()
    outputWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    outputWidget_dockWidget.setObjectName("Output")
    outputWidget_dockWidget.setWindowTitle("Output")
    outputWidget_dockWidget.setWidget(outputWidget)
    lldbWidget_dockWidget.setHidden(False)
    self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, outputWidget_dockWidget)

    breakpointsWidget.restoreState(settings)
    breakpointsWidget_dockWidget = QtGui.QDockWidget()
    breakpointsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    breakpointsWidget_dockWidget.setObjectName("Breakpoints")
    breakpointsWidget_dockWidget.setWindowTitle("Breakpoints")
    breakpointsWidget_dockWidget.setWidget(breakpointsWidget)
    breakpointsWidget_dockWidget.setHidden(True)
    self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, breakpointsWidget_dockWidget)

    watchpointsWidget.restoreState(settings)
    watchpointsWidget_dockWidget = QtGui.QDockWidget()
    watchpointsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
    watchpointsWidget_dockWidget.setObjectName("Watchpoints")
    watchpointsWidget_dockWidget.setWindowTitle("Watchpoints")
    watchpointsWidget_dockWidget.setWidget(watchpointsWidget)
    watchpointsWidget_dockWidget.setHidden(True)
    self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, watchpointsWidget_dockWidget)
    
    self.restoreGeometry(settings.value("mainWindow/geometry"))
    self.restoreState(settings.value("mainWindow/state"))

    windowMenu = QtGui.QMenu("&Windows")
    # toggleSourceAction = windowMenu.addAction("Source")
    # toggleSourceAction.setCheckable(True)
    # toggleSourceAction.setChecked(not sourceWidget_dockWidget.isHidden())
    # toggleSourceAction.toggled.connect(lambda checked: sourceWidget_dockWidget.setHidden(not checked))
    toggleDisassemblyAction = windowMenu.addAction("Disassembly")
    toggleDisassemblyAction.setCheckable(True)
    toggleDisassemblyAction.setChecked(not disassemblyWidget_dockWidget.isHidden())
    toggleDisassemblyAction.toggled.connect(lambda checked: disassemblyWidget_dockWidget.setHidden(not checked))
    windowMenu.addSeparator()
    toggleStackAction = windowMenu.addAction("Stack")
    toggleStackAction.setCheckable(True)
    toggleStackAction.setChecked(not stackWidget_dockWidget.isHidden())
    toggleStackAction.toggled.connect(lambda checked: stackWidget_dockWidget.setHidden(not checked))
    toggleThreadsAction = windowMenu.addAction("Threads")
    toggleThreadsAction.setCheckable(True)
    toggleThreadsAction.setChecked(not threadsWidget_dockWidget.isHidden())
    toggleThreadsAction.toggled.connect(lambda checked: threadsWidget_dockWidget.setHidden(not checked))
    windowMenu.addSeparator()
    toggleLocalsAction = windowMenu.addAction("Locals")
    toggleLocalsAction.setCheckable(True)
    toggleLocalsAction.setChecked(not localsWidget_dockWidget.isHidden())
    toggleLocalsAction.toggled.connect(lambda checked: localsWidget_dockWidget.setHidden(not checked))
    toggleRegistersAction = windowMenu.addAction("Registers")
    toggleRegistersAction.setCheckable(True)
    toggleRegistersAction.setChecked(not registersWidget_dockWidget.isHidden())
    toggleRegistersAction.toggled.connect(lambda checked: registersWidget_dockWidget.setHidden(not checked))
    windowMenu.addSeparator()
    toggleBreakpointsAction = windowMenu.addAction("Breakpoints")
    toggleBreakpointsAction.setCheckable(True)
    toggleBreakpointsAction.setChecked(not breakpointsWidget_dockWidget.isHidden())
    toggleBreakpointsAction.toggled.connect(lambda checked: breakpointsWidget_dockWidget.setHidden(not checked))
    toggleWatchpointsAction = windowMenu.addAction("Watchpoints")
    toggleWatchpointsAction.setCheckable(True)
    toggleWatchpointsAction.setChecked(not watchpointsWidget_dockWidget.isHidden())
    toggleWatchpointsAction.toggled.connect(lambda checked: watchpointsWidget_dockWidget.setHidden(not checked))
    windowMenu.addSeparator()
    toggleSourcesAction = windowMenu.addAction("Sources")
    toggleSourcesAction.setCheckable(True)
    toggleSourcesAction.setChecked(not sourcesWidget_dockWidget.isHidden())
    toggleSourcesAction.toggled.connect(lambda checked: sourcesWidget_dockWidget.setHidden(not checked))
    menuBar.addMenu(windowMenu)

  def closeEvent(self, event):
    self.__settings.setValue("mainWindow/state", self.saveState())
    breakpointsWidget.saveState(settings)
    outputWidget.saveState(settings)
    # lldbWidget.saveState(settings)
    disassemblyWidget.saveState(settings)
    sourcesWidget.saveState(settings)
    threadsWidget.saveState(settings)
    stackWidget.saveState(settings)
    registersWidget.saveState(settings)
    localsWidget.saveState(settings)
    self.__settings.setValue("mainWindow/geometry", self.saveGeometry())

mainWindow = MainWindow(preferences)
mainWindow.show()

lldbDisplay.appendDebuggerOutput("Welcome to zBug version %s!\n" % app.applicationVersion())

fabricSocket = None
if config['connectFabric']:
  lldbDisplay.appendDebuggerOutput("Waiting to connect to Fabric Engine process...\n")

  # [andrew 20140314] don't auto-connect if there are arguments passed
  if len(arguments) < 1:
    pidpath = os.environ['HOME']+'/.fabric-engine/.private/fabric.pid'
    try:
      pid = open(pidpath).read()
      os.kill(int(pid), 0)
      options.pid = pid
      print "Found existing Fabric Engine process "+str(pid)
    except Exception as e:
      pass

  class FabricSocket(object):
    def __init__(self):
      self.pending = ''
      self.messages = []
      self.connected = False
      self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      self.update()

    def update(self, timeout=0):
      # FIXME this needs to triggered on attach/launch
      if not self.connected:
        try:
          self.sock.connect(('127.0.0.1', 3132))
          self.connected = True
          lldbDisplay.appendDebuggerOutput("Connected to Fabric Engine process\n")
        except Exception as e:
          # lldbDisplay.appendDebuggerOutput("Failed to connect to Fabric Engine process: %s\n" % str(e))
          return
      (r,w,x) = select.select([self.sock.fileno()], [], [], timeout)
      didRead = False
      if len(r) > 0:
        self.handleMessage(self.readMessage())
        didRead = True
      while len(self.messages) > 0:
        self.handleMessage(self.readMessage())
        didRead = True
      return didRead

    def readMessage(self):
      if len(self.messages) > 0:
        return json.loads(self.messages.pop(0))
      while self.pending.find('\n') == -1:
        self.pending += self.sock.recv(20*1024)
      self.messages = self.pending.split('\n')
      self.pending = self.messages.pop()
      return json.loads(self.messages.pop(0))

    def handleMessage(self, data):
      global fabricSourceCode
      if data['cmd'] != 'SourceCode':
        raise Exception('unexpected message from Fabric: '+str(data['cmd']))
      if 'filename' in data['data']:
        filename = data['data']['filename']
        source = data['data']['sourceCode']
        remove = data['data']['remove']
        # [andrew 20140123] FIXME incorrectly assume unique filenames
        if remove == 1:
          del fabricSourceCode[os.path.basename(filename)]
        else:
          fabricSourceCode[os.path.basename(filename)] = source

  fabricSocket = FabricSocket()
  # [andrew 20140306] read all available data
  while fabricSocket.update(0.5):
    pass
  fabricSocket.timer = QtCore.QTimer()
  fabricSocket.timer.timeout.connect(fabricSocket.update)
  fabricSocket.timer.start(100)

timer = QtCore.QTimer()
timer.timeout.connect(debugger.handleEvents)
timer.start(100)

lldbCommandWidget.executeCommand(
  "settings set -- auto-confirm true"
  )

if options.pid is not None:
  lldbCommandWidget.executeCommand(
    "process attach --pid=%s" % options.pid
    )
  threadsWidget.updateDisplay()
  sourcesWidget.updateDisplay()
else:
  if len(arguments) < 1:
    parser.print_help()
    sys.exit(1)

  # Search PATH for executable
  def resolveExecutable(executable):
    try:
      if stat.S_ISREG(os.stat(executable).st_mode):
        return executable
    except Exception:
      pass

    pathDirs = os.environ['PATH'].split(":")
    for pathDir in pathDirs:
      pathedExecutable = os.path.join(pathDir, executable)
      try:
        if stat.S_ISREG(os.stat(pathedExecutable).st_mode):
          return pathedExecutable
      except Exception:
        pass

    print "Unable to find executable '%s'" % executable
    sys.exit(1)
  executable = resolveExecutable(arguments[0])

  lldbCommandWidget.executeCommand(
    "target create \"%s\"" % executable
    )
  if len(arguments) > 1:
    lldbCommandWidget.executeCommand(
      "settings set -- target.run-args %s" % (" ".join(map(lambda arg: ("\"%s\"" % arg), arguments[1:])))
      )
  lldbCommandWidget.executeCommand(
    "process launch --stop-at-entry"
    )
lldbCommandWidget.setFocus()

code = app.exec_()
fabricSocket = None
sys.exit(code)
