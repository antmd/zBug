#!/usr/bin/python
# export PYTHONPATH=/Developer/Library/PrivateFrameworks/LLDB.framework/Resources/Python

version = "0.1.0"

import lldb, sys, os
from PySide import QtCore, QtGui

if len(sys.argv) <= 1:
  print "Usage: llvd <executable> [<arg> ...]"
  sys.exit(1)
executable = sys.argv[1]
arguments = sys.argv[2:]

debugger = lldb.SBDebugger.Create()
debugger.SetAsync(True)

target = debugger.CreateTargetWithFileAndArch(executable, lldb.LLDB_ARCH_DEFAULT)

app = QtGui.QApplication(sys.argv)
app.setOrganizationName("zBug")
app.setApplicationName("zBug")

font = QtGui.QFont()
font.setPointSize(12)
font.setFamily("Courier")

class LineNumberArea(QtGui.QWidget):
  def __init__(self, codeWidget):
    QtGui.QWidget.__init__(self, codeWidget)
    self.__codeWidget = codeWidget

  def sizeHint(self):
    return QtCore.QSize(self.__codeWidget.lineNumberAreaWidth(), 0)

  def paintEvent(self, event):
    self.__codeWidget.lineNumberAreaPaintEvent(event)

class CodeWidget(QtGui.QPlainTextEdit):
  def __init__(self, parent=None):
    QtGui.QPlainTextEdit.__init__(self, parent)

    self.__files = {}

    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setFont(font)

    lineNumberArea = LineNumberArea(self)
    self.__lineNumberArea = lineNumberArea

    def updateLineNumberAreaWidth(newBlockCount):
      self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)
    self.blockCountChanged.connect(updateLineNumberAreaWidth)

    def updateLineNumberArea(rect, dy):
      if dy != 0:
        lineNumberArea.scroll(0, dy)
      else:
        lineNumberArea.update(0, rect.y(), lineNumberArea.width(), rect.height())

      if rect.contains(self.viewport().rect()):
        updateLineNumberAreaWidth(0)
    self.updateRequest.connect(updateLineNumberArea)

    def highlightCurrentLine():
      extraSelections = []
      if True: #not self.isReadOnly():
        selection = QtGui.QTextEdit.ExtraSelection()

        lineColor = QtGui.QColor(QtCore.Qt.yellow).lighter(160)

        selection.format.setBackground(lineColor)
        selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
        selection.cursor = self.textCursor()
        selection.cursor.clearSelection()
        extraSelections.append(selection)
      self.setExtraSelections(extraSelections);
    self.cursorPositionChanged.connect(highlightCurrentLine)

    updateLineNumberAreaWidth(0)
    highlightCurrentLine()

  def resizeEvent(self, event):
    QtGui.QWidget.resizeEvent(self, event)
    cr = self.contentsRect()
    self.__lineNumberArea.setGeometry(
      QtCore.QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height())
      )

  def lineNumberAreaWidth(self):
    digits = 1
    max = self.blockCount()
    if max < 1:
      max = 1
    while max >= 10:
      max = max / 10
      digits = digits + 1
    return 3 + self.fontMetrics().width('9') * digits + 3

  def lineNumberAreaPaintEvent(self, event):
    lineNumberArea = self.__lineNumberArea
    painter = QtGui.QPainter(lineNumberArea)
    painter.fillRect(event.rect(), QtCore.Qt.lightGray)
    block = self.firstVisibleBlock()
    blockNumber = block.blockNumber()
    top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
    bottom = top + int(self.blockBoundingRect(block).height())
    while block.isValid() and top <= event.rect().bottom():
      if block.isVisible() and bottom >= event.rect().top():
        blockNumberText = str(blockNumber + 1)
        painter.setPen(QtCore.Qt.black)
        painter.drawText(
          0, top,
          lineNumberArea.width() - 3, self.fontMetrics().height(),
          QtCore.Qt.AlignRight, blockNumberText
          )
      block = block.next()
      top = bottom
      bottom = top + int(self.blockBoundingRect(block).height())
      blockNumber = blockNumber + 1

  def moveToLine(self, lineNumber):
    document = self.document()
    block = document.findBlockByLineNumber(lineNumber-1)
    textCursor = self.textCursor()
    textCursor.setPosition(block.position())
    self.setTextCursor(textCursor)

  def setFrame(self, frame):
    compileUnit = frame.GetCompileUnit()
    fileSpec = compileUnit.GetFileSpec()
    filename = fileSpec.GetFilename()
    if filename:
      if not filename in self.__files:
        f = open(filename, 'r')
        contents = f.read()
        f.close()
        self.__files[filename] = contents
      else:
        contents = self.__files[filename]
      self.setPlainText(contents)
      lineEntry = frame.GetLineEntry()
      line = lineEntry.GetLine()
      self.moveToLine(line)
    else:
      self.setPlainText("")

codeWidget = CodeWidget()
codeWidget.setReadOnly(True)

class DisassemblyWidget(QtGui.QPlainTextEdit):
  def __init__(self, parent=None):
    QtGui.QPlainTextEdit.__init__(self, parent)

    self.setFont(font)
    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)

  def frame(self):
    return self.__frame

  def setFrame(self, frame):
    self.__frame = frame
    function = frame.GetFunction()
    instructions = function.GetInstructions(target)
    contents = ""
    count = instructions.GetSize()
    for i in range(0, count):
      instruction = instructions.GetInstructionAtIndex(i)
      contents += str(instruction)
      contents += "\n"
    self.setPlainText(contents)

disassemblyWidget = DisassemblyWidget()

class ValueWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self):
    QtGui.QTreeWidgetItem.__init__(self)

    self.setFont(0, font)
    self.setFont(1, font)
    self.setFont(2, font)

    self.__staticColor = QtGui.QColor(QtCore.Qt.white)
    self.__dynamicColor = QtGui.QColor(QtCore.Qt.red).lighter(190)

  def value(self):
    return self.__value

  def setValue(self, value, includeType):
    column = 0

    self.setText(column, value.GetName())
    column += 1

    if includeType:
      self.setText(column, value.GetTypeName())
      column += 1

    self.setText(column, value.GetValue())
    if value.GetValueDidChange():
      self.setBackground(column, self.__dynamicColor)
    else:
      self.setBackground(column, self.__staticColor)
    column += 1

    self.takeChildren()
    count = value.GetNumChildren()
    for i in range(0, count):
      childValue = value.GetChildAtIndex(i)
      childValueWidgetItem = ValueWidgetItem()
      childValueWidgetItem.setValue(childValue)
      self.addChild(childValueWidgetItem)

class LocalsWidget(QtGui.QTreeWidget):
  def __init__(self):
    QtGui.QTreeWidget.__init__(self)

    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(12)
    self.setHeaderLabels([
      "Name",
      "Type",
      "Value"
    ])

  def frame(self):
    return self.__frame

  def setFrame(self, frame):
    self.__frame = frame
    includeArguments = True
    includeLocals = True
    includeStatics = True
    in_scope_only = True
    variables = frame.GetVariables(
      includeArguments,
      includeLocals,
      includeStatics,
      in_scope_only
      )
    count = variables.GetSize()
    for i in range(0, count):
      value = variables.GetValueAtIndex(i)
      if i < self.topLevelItemCount():
        valueWidgetItem = self.topLevelItem(i)
      else:
        valueWidgetItem = ValueWidgetItem()
        self.addTopLevelItem(valueWidgetItem)
      valueWidgetItem.setValue(value, includeType=False)
    while self.topLevelItemCount() > count:
      self.takeTopLevelItem(count)
    self.resizeColumnToContents(0)
    self.resizeColumnToContents(1)

localsWidget = LocalsWidget()

class RegistersWidget(QtGui.QTreeWidget):
  def __init__(self):
    QtGui.QTreeWidget.__init__(self)

    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(12)
    self.setHeaderLabels([
      "Name",
      "Value"
    ])

  def frame(self):
    return self.__frame

  def setFrame(self, frame):
    self.__frame = frame
    registers = frame.GetRegisters()
    count = registers.GetSize()
    for i in range(0, count):
      value = registers.GetValueAtIndex(i)
      if i < self.topLevelItemCount():
        valueWidgetItem = self.topLevelItem(i)
      else:
        valueWidgetItem = ValueWidgetItem()
        self.addTopLevelItem(valueWidgetItem)
      valueWidgetItem.setValue(value, includeType=False)
      valueWidgetItem.setFirstColumnSpanned(True)
    while self.topLevelItemCount() > count:
      self.takeTopLevelItem(count)
    self.resizeColumnToContents(0)
    self.resizeColumnToContents(1)

registersWidget = RegistersWidget()

class StackWidgetItem(QtGui.QTreeWidgetItem):
  def __init__(self):
    QtGui.QTreeWidgetItem.__init__(self)
    self.setFont(0, font)
    self.setFont(1, font)
    self.setTextAlignment(1, QtCore.Qt.AlignRight)
    self.setFont(2, font)

  def frame(self):
    return self.__frame

  def setFrame(self, frame):
    self.__frame = frame
    lineEntry = frame.GetLineEntry()
    line = lineEntry.GetLine()
    self.setText(0, "%d" % frame.GetFrameID())
    self.setText(1, "0x%x" % frame.GetPC())
    self.setText(2, "%s:%d" % (frame.GetFunctionName(), line))

class StackWidget(QtGui.QTreeWidget):
  def __init__(
    self,
    codeWidget,
    disassemblyWidget,
    localsWidget,
    registersWidget
    ):
    QtGui.QTreeWidget.__init__(self)

    self.__codeWidget = codeWidget
    self.__disassemblyWidget = disassemblyWidget
    self.__localsWidget = localsWidget
    self.__registersWidget = registersWidget

    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setIndentation(0)
    self.setHeaderLabels([
      "#",
      "PC",
      "Function"
    ])

    def currentItemChanged(newItem, oldItem):
      self.updateFrame()
    self.currentItemChanged.connect(currentItemChanged)

  def updateFrame(self):
    currentItem = self.currentItem()
    if currentItem:
      frame = currentItem.frame()
      self.__codeWidget.setFrame(frame)
      self.__disassemblyWidget.setFrame(frame)
      self.__localsWidget.setFrame(frame)
      self.__registersWidget.setFrame(frame)

  def setThread(self, thread):
    if thread:
      count = thread.GetNumFrames()
    else:
      count = 0
    for i in range(0, count):
      frame = thread.GetFrameAtIndex(i)
      if i < self.topLevelItemCount():
        stackWidgetItem = self.topLevelItem(i)
      else:
        stackWidgetItem = StackWidgetItem()
        self.addTopLevelItem(stackWidgetItem)
      stackWidgetItem.setFrame(frame)
    while self.topLevelItemCount() > count:
      self.takeTopLevelItem(count)

    if self.topLevelItemCount() > 0:
      self.setCurrentItem(self.topLevelItem(0))
    self.resizeColumnToContents(0)
    self.resizeColumnToContents(1)
    self.updateFrame()

stackWidget = StackWidget(
  codeWidget,
  disassemblyWidget,
  localsWidget,
  registersWidget
  )

class OutputWidget(QtGui.QTextEdit):
  def __init__(self):
    QtGui.QTextEdit.__init__(self)

    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setFont(font)

    self.__stdoutColor = QtGui.QColor(QtCore.Qt.black)
    self.__stderrColor = QtGui.QColor(QtCore.Qt.red).lighter(50)

  def appendStdout(self, text):
    self.setTextColor(self.__stdoutColor)
    cursor = self.textCursor()
    cursor.insertText(text)

  def appendStderr(self, text):
    self.setTextColor(self.__stderrColor)
    cursor = self.textCursor()
    cursor.insertText(text)

outputWidget = OutputWidget()

lineEdit = QtGui.QLineEdit()

class LLDBDisplay(QtGui.QTextEdit):
  def __init__(self, parent=None):
    QtGui.QTextEdit.__init__(self, parent)

    self.setReadOnly(True)
    self.setFocusPolicy(QtCore.Qt.NoFocus)
    self.setFont(font)

    self.__commandColor = QtGui.QColor(QtCore.Qt.blue).lighter(50)
    self.__successOutputColor = QtGui.QColor(QtCore.Qt.green).lighter(50)
    self.__failureOutputColor = QtGui.QColor(QtCore.Qt.green).lighter(50)

  def appendCommand(self, text):
    self.setTextColor(self.__commandColor)
    cursor = self.textCursor()
    cursor.insertText("> " + text + "\n")

  def appendDebuggerOutput(self, text):
    self.setTextColor(self.__successOutputColor)
    cursor = self.textCursor()
    cursor.insertText(text)

  def appendDebuggerErrorOutput(self, text):
    self.setTextColor(self.__failureOutputColor)
    cursor = self.textCursor()
    cursor.insertText(text)

lldbDisplay = LLDBDisplay()

lldbCommandLayout = QtGui.QHBoxLayout()
lldbCommandLayout.addWidget(QtGui.QLabel("lldb:"))
lldbCommandLayout.addWidget(lineEdit)

lldbLayout = QtGui.QVBoxLayout()
lldbLayout.addWidget(lldbDisplay)
lldbLayout.addLayout(lldbCommandLayout)

lldbWidget = QtGui.QWidget()
lldbWidget.setLayout(lldbLayout)

stackWidget_dockWidget = QtGui.QDockWidget()
stackWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
stackWidget_dockWidget.setWindowTitle("Stack")
stackWidget_dockWidget.setWidget(stackWidget)

codeWidget_dockWidget = QtGui.QDockWidget()
codeWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
codeWidget_dockWidget.setWindowTitle("Source Code")
codeWidget_dockWidget.setWidget(codeWidget)

disassemblyWidget_dockWidget = QtGui.QDockWidget()
disassemblyWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
disassemblyWidget_dockWidget.setWindowTitle("Disassembly")
disassemblyWidget_dockWidget.setWidget(disassemblyWidget)

localsWidget_dockWidget = QtGui.QDockWidget()
localsWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
localsWidget_dockWidget.setWindowTitle("Locals")
localsWidget_dockWidget.setWidget(localsWidget)

registersWidget_dockWidget = QtGui.QDockWidget()
registersWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
registersWidget_dockWidget.setWindowTitle("Registers")
registersWidget_dockWidget.setWidget(registersWidget)

outputWidget_dockWidget = QtGui.QDockWidget()
outputWidget_dockWidget.setFeatures(QtGui.QDockWidget.DockWidgetMovable|QtGui.QDockWidget.DockWidgetFloatable)
outputWidget_dockWidget.setWindowTitle("Output")
outputWidget_dockWidget.setWidget(outputWidget)

settings = QtCore.QSettings()

class MainWindow(QtGui.QMainWindow):
  def __init__(self):
    QtGui.QMainWindow.__init__(self)

    settings.beginGroup("MainWindow")
    self.resize(settings.value("size", QtCore.QSize(800, 600)))
    self.move(settings.value("pos", QtCore.QPoint(200, 200)))
    settings.endGroup()

  def closeEvent(self, event):
    settings.beginGroup("MainWindow")
    settings.setValue("size", self.size())
    settings.setValue("pos", self.pos())
    settings.endGroup()

mainWindow = MainWindow()
mainWindow.setCentralWidget(lldbWidget)
mainWindow.addDockWidget(QtCore.Qt.BottomDockWidgetArea, registersWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.BottomDockWidgetArea, localsWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.LeftDockWidgetArea, stackWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.RightDockWidgetArea, outputWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.TopDockWidgetArea, codeWidget_dockWidget)
mainWindow.addDockWidget(QtCore.Qt.TopDockWidgetArea, disassemblyWidget_dockWidget)
mainWindow.show()

# print "Setting a breakpoint at '%s'" % "main"
# main_bp = target.BreakpointCreateByName("main", target.GetExecutable().GetFilename())

class ZBugProcess:
  def __init__(self, debugger, args, cwd, lldbDisplay, stackWidget):
    self.__debugger = debugger
    self.__args = args
    self.__cwd = cwd
    self.__lldbDisplay = lldbDisplay
    self.__stackWidget = stackWidget
    self.__process = None

    launchError = lldb.SBError()
    process = target.Launch(
      debugger.GetListener(),
      arguments,
      None,   # envp
      os.getcwd(),
      None,   # stdin_path
      None,   # stdout_path
      None,   # stderr_path
      True,   # stop_at_endtry
      lldb.eLaunchFlagDebug,
      launchError
      )
    if not process or process.GetProcessID() == lldb.LLDB_INVALID_PROCESS_ID:
      raise Exception("Launch failed: " + str(launchError))

  def handleDebuggerEvents(self):
    event = lldb.SBEvent()
    while debugger.GetListener().GetNextEvent(event):
      done = False
      if event.GetBroadcaster().GetName() == "lldb.process":
        if not self.__process:
          self.__process = target.GetProcess()
        state = lldb.SBProcess.GetStateFromEvent(event)
        if state == lldb.eStateInvalid:
          # Not a state event
          print 'process event = %s' % (event)
        else:
          print "process state changed event: %s" % (lldb.SBDebugger.StateAsCString(state))
          if state == lldb.eStateStopped:
            selectedThread = None
            if self.__process.IsValid() and self.__process.GetState() == lldb.eStateStopped:
              if self.__process.GetNumThreads() > 0:
                selectedThread = self.__process.GetThreadAtIndex(0)
            self.__stackWidget.setThread(selectedThread)
          elif state == lldb.eStateExited:
            exit_desc = self.__process.GetExitDescription()
            if exit_desc:
              self.__lldbDisplay.appendDebuggerOutput("Process %u exited with status %u: %s\n" % (self.__process.GetProcessID(), self.__process.GetExitStatus(), exit_desc))
            else:
              self.__lldbDisplay.appendDebuggerOutput("Process %u exited with status %u\n" % (self.__process.GetProcessID(), self.__process.GetExitStatus()))
            self.__stackWidget.setThread(None)
            done = True
          elif state == lldb.eStateCrashed:
            self.__lldbDisplay.appendDebuggerOutput("Process %u crashed" % self.__process.GetProcessID())
            done = True
          elif state == lldb.eStateDetached:
            self.__lldbDisplay.appendDebuggerOutput("Process %u detached" % self.__process.GetProcessID())
            done = True
          elif state == lldb.eStateRunning:
            # process is running, don't say anything, we will always get one of these after resuming
            pass
          elif state == lldb.eStateUnloaded:
            self.__lldbDisplay.appendDebuggerOutput("Process %u unloaded, this shouldn't happen!!!" % self.__process.GetProcessID())
            done = True
          elif state == lldb.eStateConnected:
            pass
          elif state == lldb.eStateAttaching:
            pass
          elif state == lldb.eStateLaunching:
            pass
      else:
        print 'Non-process event = %s' % (event)
      process_stdout = self.__process.GetSTDOUT(1024)
      if process_stdout:
        outputWidget.appendStdout(process_stdout)
        while process_stdout:
          process_stdout = self.__process.GetSTDOUT(1024)
          outputWidget.appendStdout(process_stdout)
      process_stderr = self.__process.GetSTDERR(1024)
      if process_stderr:
        outputWidget.appendStderr(process_stderr)
        while process_stderr:
          process_stderr = self.__process.GetSTDERR(1024)
          outputWidget.appendStderr(process_stderr)
      if done:
        self.__process = None

command_interpreter = debugger.GetCommandInterpreter()
def executeCommand():
  command = str(lineEdit.text())
  lldbDisplay.appendCommand(command)
  lineEdit.clear()
  return_obj = lldb.SBCommandReturnObject()
  command_interpreter.HandleCommand(command, return_obj)
  if return_obj.Succeeded():
    lldbDisplay.appendDebuggerOutput(return_obj.GetOutput())
  else:
    lldbDisplay.appendDebuggerErrorOutput(return_obj.GetError())
lineEdit.returnPressed.connect(executeCommand)
lineEdit.setFocus()

zBugProcess = ZBugProcess(
  debugger,
  arguments,
  os.getcwd(),
  lldbDisplay,
  stackWidget
  )

timer = QtCore.QTimer()
timer.timeout.connect(zBugProcess.handleDebuggerEvents)
timer.start(100)

lldbDisplay.appendDebuggerOutput("Welcome to zBug version " + version + "\n")
lldbDisplay.appendDebuggerOutput("Process has been launched and stopped.\n")

sys.exit(app.exec_())


